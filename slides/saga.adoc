:source-highlighter: highlight.js
:revealjs_theme: redhat
:revealjs_controls: false
:revealjs_center: true
:revealjs_transition: fade

:images: ./misc


= Saga transactions
Ondra Chaloupka / ochaloup@redhat.com

== !

image:{images}/saga/wfly_narayana.png[role="noborder"]

[NOTE.speaker]
--
* Red Hat (https://developers.redhat.com)
* Wild Fly (http://wildfly.io)
* Naryana (http://narayana.io)
--

== A saga transaction

image:{images}/entertain/wtf2.jpg[role="noborder"]

== A transaction

* An atomic unit of the work where everything or nothing is finished.
* [red]#A# [blue]#C# [green]#I# [blue]#D# (dtomicity, consistency, isolation, durability)

== Distributed transaction (2PC)

image:{images}/saga/2pc.png[role="noborder", .stretch]

[NOTE.speaker]
--
* distributed transaction coordinates non-homogenous participants
* scaling troubles in distributed environment
* https://developer.jboss.org/wiki/TwoPhaseCommit2PC
--


== Troubles of distributed txns (MSA world)

* locking
* data coupling
* scaling

== Saga transaction

* Saga paper (H. Garcia-Molina, K. Salem;  1987)
* Enventual consistency - relaxing ACID properties
* Web services: WS-BA spec
* design patterns for SOA and MSA architecture

[NOTE.speaker]
--
Original paper talks about Saga as a solution for long-lived database transactions.
We can use it for distributed environment too for not using two phase commit (a.k.a. locks).

Other names

* Saga action, Saga transactions
* Compensating transactions, compensation transaction
* long running actions

* https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf (Princeton University, 1987)
* http://jbossts.blogspot.cz/2017/06/sagas-and-how-they-differ-from-two.html
* http://microservices.io/patterns/data/saga.html
* https://www.youtube.com/watch?v=0UTOLRTwOX0 (JOTB17, Distributed Sagas: A Protocol for Coordinating Microservices, Caitie McCaffrey)
* http://docs.oasis-open.org/ws-tx/wstx-wsba-1.1-spec-os/wstx-wsba-1.1-spec-os.html (Web Services Business Activity, 2007)
*
--

== Saga transaction

image:{images}/saga/saga.png[role="noborder", .stretch]

[NOTE.speaker]
--
Concept of long lived transaction.

The Saga defines unit of work work that could be aborted and we relax isolation.

Standard ACID transaction is expected to be a short amount of work done in short time.
This expectation is based on the fact that ACID transaction holds resources (locks)
and prevents other concurrent transaction using the same data to proceed (mainly when the
both of them hit writing the same record, reading concurrently could be somehow solved by MVCC - Snapshot isolation).

What if we want to have long transaction spans request over network (WS, REST) combined with insertion to a database.
What if we consider popular example of reserving a flight, taxi to a hotel and the hotel,
which we would like to be a single operation in high level point of view - I mean when I book a hotel from some date,
I need to be sure that the flight for that date is booked too and having taxi on particular date being prepared
for me. Confirmation of the hotel could take "long" time and during that time I need to hold reservation
for the flight. When booking fails I need to cancel the flight reservation too. At this particular example
it's suitable to hold resources (locks) as it could block other reservation to happen.

This is really popular example in many articles and it is in fact real for many use cases.
But what is important is that pointing to the fact that
holding resources/locks (for long time) could be a bad fit which not permitting concurrent operation to proceed.
This is something with current systems have to fight with.

Trend of holding locks is represented by well-known two phase commit protocol where
each resource - each participant of the transaction (it could be a database, WS/REST call, JMS...)
starts its own local transaction and that local transaction holds resources of particular system
(it holds locks on the resource, implementation depends system - in example of DB as mentioned
there is MVCC which does not lock for concurrent reads). The resource is hold during the whole time
of processing until commit is called on the local transaction.

How to not holding lock and permit higher transaction throughput? The answer could be Saga.
Even we didn't define it so far we can say it comes with idea of splitting this big
transaction to small ones where each local transaction is finished as soon as possible
and the set of the already finished transactions defines a work of unit. This breaks
ACID isolation right at the place but Saga provides handling to grant atomicity.
--


== Saga transaction (again)

image:{images}/saga/<flight-taxi-hotel-booking-example>.png[role="noborder", .stretch]


== Saga

[NOTE.speaker]
--
The concept of the original paper talks about single node database but it could
be applied to distributed transactions (as was already shown).

Saga could be classified as `Base` transaction (at least from my understanding)
as it does not lock resources a.k.a locks and letting data of resources being available
for other transactions to work with.

TODO: _add description of Saga here_

As you could see the transaction handling introduced by Saga requires the application to
define compensation actions or define actions as idempotent (you can repeat operation on the
resource multiple times and you will get the same result - operation being repeated not leading to a different outcome).

Still you can handle all the data integrity yourself in your application and design your system architecture
to handle with failures. It's up to you if concept of Saga is useful for you or not.

* https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf (Sagas, Priceton University, 1987)
* http://queue.acm.org/detail.cfm?id=1394128 (Base: An Acid Alternative, base transactions)
* https://www.atomikos.com/Blog/ACAPSolutionProvingBrewerWrong (A CAP Solution (Proving Brewer Wrong) aka CQRS)
--


== Narayana and Saga

* WS-BA
* Compensating transactions
* LRA

[NOTE.speaker]
--
* https://developer.jboss.org/wiki/CompensatingTransactionsWhenACIDIsTooMuch (Narayana: Compensating Transactions: When ACID is too much)
--


== Narayana LRA

```java
@Inject
private AlohaService alohaService;

@GET
@Path("/hello")
@LRA(value = LRA.Type.REQUIRED)
public List<String> hello() {
    alohaService.aloha(lraUri)
}

@POST
@PUT("/complete")
@Complete
public Response completeWork(@HeaderParam(LRAClient.LRA_HTTP_HEADER) String lraId) {
    String txId = LRAClient.getLRAId(lraId);
    System.out.printf("ActivityController completing %s%n", txId);
    return Response.ok().build();
}

@POST
@Path("/compensate")
@Compensate
public Response compensateWork(@HeaderParam(LRAClient.LRA_HTTP_HEADER) String lraId) {
    String txId = LRAClient.getLRAId(lraId);
    System.out.printf("ActivityController compensating %s%n", txId);
    return Response.ok().build();
}
```


== Others

[NOTE.speaker]
--
Microprofile spec

https://github.com/jbosstm/microprofile-sandbox/blob/0009-LRA/proposals/0009-LRA/0009-LRA.md


... and others

Event driven transactions

  * https://docs.axonframework.org/part2/sagas.html (Axon: Managing complex business transactions)
  * http://eventuate.io (Solving distributed data management problems in a microservice architecture)
  * https://docs.particular.net/nservicebus/sagas (Particular Software : .NET/Windows, Sagas)

Atomicos TCC

  * https://www.atomikos.com/Main/DownloadPublications?article=TransactionsForSOA-WhitePaper.pdf (Atomicos: Composite	Transactions for SOA)
  * https://www.infoq.com/presentations/Transactions-HTTP-REST (Atomicos: Transactions for the REST of Us, presentation
--


== !

image:{images}/entertain/cajk.jpg[role="noborder", , height="300"]
