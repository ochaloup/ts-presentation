:source-highlighter: highlight.js
:revealjs_theme: redhat
:revealjs_controls: false
:revealjs_center: true

:images: ./misc


= Transactions in Java
Ondra Chaloupka / ochaloup@redhat.com

== Transactions in Java ?

[ source, language="java" ]
----
@Stateless
public class TestBean {
    
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void doWork() {
        // do something
    }
}
----

== Transactions in Java !?

image:{images}/tagcloud.png[]

== Agenda
 * Terminology
 * Resource local transaction in Java SE
 ** Database
 ** JMS
 * Global transaction in Java SE
 ** Java Transaction API (JTA)
 ** Narayana implementation
 * Transactions in Java EE
 ** Bean managed transactions (BMT)
 ** Container managed transactions (CMT)


= Terminology corner

== A transaction
A transaction is a group of business logic statements with certain shared properties.

Which are one or more of:

Atomic, Consistent, Isolated, Durable

[NOTE.speaker]
--
 The statement above stolen from presentation of Michael Musgrove for Brno JBug, January 2015
 From user point of view a transaction is an atomic unit of the work where everything or nothing is finished.
 From developer point - we have some data and we want to save them to some store and if there is something
  running in paralel with our task we want to be isolated/warned from colisions.
 All the presentation is about resources that could  be managed - resource is database, jms, mail service, whatever connected to JCA
 Concurrency access is the main reason why we need to discuss such thing as transaction.
 Transactions tries to make programmer's life easier to give him some assurances (zaruky)
--

=== ACID
 * Atomicity
 * Consistency
 * Isolation
 * Durablitity

[NOTE.speaker]
--
 http://en.wikipedia.org/wiki/ACID, http://what-when-how.com/hibernate/transactions-and-concurrency-hibernate/
 Atomicity
  * one part of transaction fails then whole transaction fails
  * the notion that all operations are executed as an atomic unit
 Consistency
  * transaction will bring the database from one valid state to another according to defined rules (as constraints, cascades, triggers...)
  * by some definitions proclam that consistency should be maintained during the transaction execution as well (not only at transaction's ends) 
    what I understand it's ok to say that transaction keeps consistency for short lived ACID isolated transactions. but if transaction does not guarantee
    isolation then the consistency inside of transaction run could be important or rather violated
  * consistency means that a transaction works on a consistent set of data: a set of data that is hidden from other concurrently running transactions
     and that is left in a clean and consistent state after the transactions completes
  * does not mean correctness of transaction from business point of view
 Isolation
  * for transaction itself the system behaves like the paralel transactions would be run in serial order
  * concurrent execution of transactions results in a system state that would be obtained if transactions were executed serially (one by one)
 Durablitity
  * durability means that once a transaction completes, all changes made during that transaction become persistent and aren’t lost even if the system subsequently fails
--

== Other transaction "types"

 * BA (Business Activities)
 * BTP
 * WS-CAF
 * WS-TX (WA-AT and WS-BA)
 * Extended transactions
 * BASE

[NOTE.speaker]
--
  Resources
  * https://www.youtube.com/watch?v=CR8_m5_k4fQ
  * http://www.infoq.com/articles/History-of-Extended-Transactions
  Extended transactions (in Narayana)
   * umbrella term for transaction systems/protocols which relax some of the ACID guarantees (properties)
   * from part of Narayana it's protocol based on Sagus (academic research from 1997)
   ** relaxes Isolation and Consistency (it's eventually consistent)
  BA - business activities
   * BA is term from "another" world - in general it's long terming transaction (booking a flight + taxi from the airport)
   * came along with WebServices
  BTP
   * Hewlett-Packard, Oracle and BEA worked on the OASIS Business Transaction Protocol (BTP), which was aimed at business-to-business transactions in loosely coupled domains such as Web Services
   * based on 2PC protocol in general
   * The specification developed two new models for "transactions", requiring business-level decisions to be incorporated within the transaction infrastructure
   * 2001
  WS-CAF
   * ASIS Web Services Composite Application Framework (WS-CAF) TC (Defining an open framework for supporting coordinated and transactional compositions of multiple Web services applications)
   * 2006
  WS-TX
   * ideas came from CORBA model (http://www.infoq.com/articles/History-of-Extended-Transactions)
   ** coordinator responsible for sending and receiving messages of arbitrary types - called signals
   ** coordinator inteligence - enabled for specific protocol with special sets of signals being transfered
   * WS-AT: atomic transactions - 2PC
   * WS-BA: businness activities doing compensation actions
  BASE
   * ACID transaction doesn't scale
   * connected with the movement of NoSQL
   * came with CAP theorem - system could satisfy just two of these three requirements: Consistency, Availability, Parition Tolerance
   * one of the way how to handle CAP "trouble" is relaxing consistency which is where BASE goes
   ** Basic Availability -  spread data across many storage systems with a high degree of replication
   ** Soft State. - data consistency is the developer's problem and should not be handled by the database, consistency is not a goal here
   ** Eventual Consistency - system will eventually become consistent once it stops receiving input
   * some of the NoSQL databases tries to be ACID(like) -> NewSQL - FoundationDB, NuoDB, OrientDB...
--

== Transaction types

 * Top-level
 * Nested
 * Nested top-level
 * Concurrent nested

[NOTE.speaker]
--
 * Top-level transaction - transaction as we understand it
 * Nested - transaction contains other transaction. When nested rollbacks it does not mean that top-one will rollback. 
            If nested commits then the overall result depends on the top-level transaction.
 * Nested top-level - nested is invoked in context of another txn but if top-level commits 
                      it's commited independently on the outcome of the caller transaction.
 * Concurrently running nested transaction - result has to be the same as they would be run in arbitrary serial order
--

== Transaction types (contd.)

 * Resource local
 * Global transaction
 * Distributed transaction

[NOTE.speaker]
--
 Txn management
 * Resource local - transaction at level of database or JMS server
 * Global - transaction "consisting" from several resource local transactions managed by transaction manager
 * Distributed transaction - transaction spread over multiple transaction managers
--

== XA vs. Distributed transaction

 * XA - XA/Open XA architecture - multiple resources
 * Distributed - multiple transaction managers

[NOTE.speaker]
--
 In many sources under term distributed transaction means XA from point of view of this presentation (and Narayana TM in general. 
 E.g. JDBC specification talks about distributed transactions but such txn means XA transaction from point of view of this presentation.
 Narayna/JBoss/EAP point of view understands distributed transactions such ones that pass its context over a to a different transaction manager.
 XA transaction is such that contains several resources, such specified by X/Open XA architecture - meaning transaction using 2PC protocol over more resources.
 This presentation won't be about neither XA or distributed transactions (maybe about distributed in sense of context passing between EJB beans)
--

== Transactions from developer point of view

 * Local transaction model
   `connection.commit`
 * Programmatic transaction model
   `transaction.commit()`
 * Declarative transaction model
   `@TransactionAttribute(TransactionAttributeType.REQUIRED)`

[NOTE.speaker]
--
 * Local - working directly with resource/connection
 * Programmatic - not working with resource but with a transaction
 * Declarative - transactions are hidden behind of JEE layer
--

= Databases and JDBC

== Database transaction
[ source, language="sql" ]
----
BEGIN;
INSERT INTO test_table VALUES (1, 'test');
COMMIT;
----

[NOTE.speaker]
--
 PostgreSQL "syntax"
--

== Isolation level

image:{images}/db/isolation-levels-base.png[]

[NOTE.speaker]
--
 Resources
   * http://what-when-how.com/hibernate/transactions-and-concurrency-hibernate/#bookmark369
   * Java Transaction Design Strategy p53
 It's interaction of interleaving transactions
 Transaction isolation is a function of database cocurrency and database consistency - more isolation, means more consistency but less concurrency
 Hibernate increase level of isolation to moving control to application layer
  * optimistic locking adds versioning and so non-repeatable reads can't occur (or the special case when second commit replaces data of first commit)
  * pesimistic locking uses SELECT ... FOR UPDATE to lock particular record in database
--

== Lost update

image:{images}/db/01-lost-update.jpg[]

[small]#shamelessly stolen from http://what-when-how.com#

[NOTE.speaker]
--
 two transactions doing update in parallel but first does commit and second rollbacks - then the commit of first willl be lost
--

== Dirty reads

image:{images}/db/02-dirty-reads.jpg[]

[small]#shamelessly stolen from http://what-when-how.com#

[NOTE.speaker]
--
 two transactions running in paralel. first does update and second shortly after that reads the same data - the update will be wisible
 despite the fact that the first transaction is rollbacked in a while
--

== Non-repeatable reads

image:{images}/db/03-non-repeatable-reads[]

[small]#shamelessly stolen from http://what-when-how.com#

[NOTE.speaker]
--
 when first transaction does two reads of some data already saved! in transaction - one after another - and between these two actions second transaction does commit
 the second read of the first transaction will get another data then the first read
--

== Phantom reads

image:{images}/db/04-phantom-reads.jpg[]

[small]#shamelessly stolen from http://what-when-how.com#

[NOTE.speaker]
--
 when transaction does select over more rows it could reads different count of rows in two subsequent queries when another transaction was meanwhile commited and
 added a row which is contained in the searched query
--

== Quiz
[ source, language="java" ]
----
java.sql.Connection connection = DriverManager.getConnection(...)
Statement st = connection.createStatement();
st.execute("INSERT INTO table VALUES (1, 'EAP QE')");
----

[NOTE.speaker]
--
 Where is the transaction?
--

== Quiz - Answer
[ source, language="java" ]
----
java.sql.Connection connection = DriverManager.getConnection(...)
connection.setAutoCommit(false);
Statement st = connection.createStatement();
st.execute("INSERT INTO table VALUES (1, 'EAP QE')");
connection.commit();
----

[NOTE.speaker]
--
 Where is the transaction?
--

== JDBC
 * Connection.setAutoCommit
 * Connection.setTransactionIsolation

[NOTE.speaker]
--
 * transactions are managed by Connection.setAutoCommit method
--

== JDBC batch
[ source, language="java" ]
----
java.sql.Connection connection = DriverManager.getConnection(...)
connection.setAutoCommit(false);
Statement st = connection.createStatement();
st.addBatch("INSERT INTO table VALUES (1, 'JTA')");
st.addBatch("INSERT INTO table VALUES (2, 'JCA')");
int[] updateCounts = st.executeBatch();
connection.commit();
----

[NOTE.speaker]
--
 Some performance optimalizations for batching could be taken by database.
 But from test log there is no any special handling for simple cases as this one.
 There are just two inserts one after another.
 Butch return simple count of changes. It can't return ResultSet.
--

== JDBC "nested" transactions
[ source, language="java" ]
----
java.sql.Connection connection = DriverManager.getConnection(...)
connection.setAutoCommit(false);
Statement st = connection.createStatement();
st.execute("INSERT INTO table VALUES (1, 'EAP 6')");
Savepoint savePoint = connection.setSavepoint();
st.execute("UPDATE table SET product='EAP 7' WHERE id=1");
connection.rollback(savePoint);
connection.commit();
----

== Be aware of DDL commands
 * DDL - data definition language (CREATE, DROP...)
 * DML - data manipulation language (INSERT, UPDATE...)
 * lot of Databases does not support transactional DDL

[NOTE.speaker]
--
Resource:
 https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis
 PostgreSQL do DDL in transaction
 e.g. Oracle (probably - not up-to-date info) first commits currently running DML and then does DDL in separate transaction
--

= JMS

== Transactions and redelivery
image:{images}/jms/jms-transaction-redelivery.png[]


[NOTE.speaker]
--
 Resources: http://www.javaworld.com/article/2074123/java-web-development/transaction-and-redelivery-in-jms.html
 First - simplifiyng abilities of JMS
 Second - aim is that we want being safe thta message was really delivered
 * if message waits in queue (in JMS provider) then the its fate in case of failure depends on delivery mode: *persistent* or *nonpersistent*
 ** HornetQ settings: <persistence-enabled>true</persistence-enabled>
 * if message is being sent then acknowledgement that was received is driven by by transaction/redelivery modes
 * all this is set when *Session* is created
--

== Session creation
[ source, language="java" ]
----
Connection.createSession(boolean transacted, int acknowledgeMode)
----
 * `Session.AUTO_ACKNOWLEDGE`
 * `Session.DUPS_OK_ACKNOWLEDGE`
 * `Session.CLIENT_ACKNOWLEDGE`
 * `Session.SESSION_TRANSACTED`

[NOTE.speaker]
--
 If session is set as transacted = true then acknowledgeMode is ignored
 Or at least it should be - this is not true for Genereic JMS RA (Tibco and EAP)
 * commit() is called on Session (transacted=true)
 * acknowledge() is called Message (transacted=false, acknowledgeMode=CLIENT_ACKNOWLEDGE)
 AUTO - If a failure occurs while executing the receive() method or the onMessage() method, the message is automatically redelivered.
        The JMS provider carefully manages message redelivery and guarantees once-only delivery semantics.
 DUPS - With less overhead than auto mode, in duplicates okay mode, the JMS provider guarantees at-least-once message delivery.
        During failure recovery, certain messages are probably delivered more than once.
 CLIENT - In client mode, invoking the Message class's acknowledge() method explicitly acknowledges the message.
          In fact, using the acknowledge() method makes sense when only using the client mode.
--

== Quiz

What happens on JMS transaction rollback?

== Quiz - Answer
 * automatic redelivery rollbacked messages
 * redelivery count could be defined
 * redelivery timeout could be defined
 * exceptional destination (message is non-deliverable)
 ** message is only logged
 ** message is forwarded to an error destination
 ** message is forgotten

[NOTE.speaker]
--
 redelivery count - number of tries to deliver message, redelivery count is important as not deliverable messages can eventually crash the system
 redelivery timeout - time to wait before redelivering the message. This delay lets the JMS provider and the application recover to a stable state.
 when rollback it could be set whether rollbacked message goes to the end or to the front of the queue - it depends on some config etc.
--


= Java EE

[NOTE.speaker]
--
 When speaking about Transaction manager then Narayana/Arjuna is meant
 When speaking about appliation server then JBoss EAP/Wildfly is meant
--

= JTA

[NOTE.speaker]
--
 TODO: Ideas to check:
  * nested transactions
  * JTS and Corba - how to use it
--

== Quiz

What is the JTA for?

[NOTE.speaker]
--
 We know that we can manage database or jms resource directly why such thing is not
 covered by Java EE container and we need some specification of transaction?
 What that transaction for?
 What the JTA could offer to me?
--

== Quiz

 * Managing transactions :)
 * Machinery of two phase commit protocol
 * Recovery management
 * Transaction timeout could be set
 * Distributed transactions

[NOTE.speaker]
--
 It's standardized way how container can communicate with transaction.
 Specialized thread (in background or foreground) which is able to stop running transaction after specified amount of time.
 It's way how more then one resource could be part of one ACID transaction (DB + JMS + Mail service create one txn)
--

== JTA a bit on history
 * Implementation of X/Open XA architecture (JSR 907)
 * Versions
 ** 1.0 - year 2000
 ** 1.1 - year 2007 (EE 5)
 ** 1.2 - year 2013 (EE 7)

[NOTE.speaker]
--
 Java Transaction API ensures that we can use XA transactions (2PC)
 * X/Open XA - open group for distributed transaction processing (DTP)
 * 1.0 - All the stuff (UserTransaction)
 * 1.1 - TransactionSynchronizationRegistry - used by component like JPA to registry in order and being able to manage transaction on the registred hook
 * 1.2 - @Transactional, @TransactionScoped - ripping transaction of the EJB (with CDI to CDI beans, Servlet, JAX-RS...)
--

== Specifications - a messy thing
 * JTA (JSR 907) maps XA spec to Java
 * XA spec from year 1991 by The Open Group
 * JTS spec maps OTS spec to Java
 * OTS spec by Object management Group (OMG)
 * JCA, JMS, JDBC, Java EE Platform spec contains sections on TM
 * WS-AT and WS-BA under OASIS standard

[NOTE.speaker]
--
 There is no central place with information about transactions in Java
 JTS specifies the implementation of a transaction manager which supports the JTA specification at the high-level and implements the Java mapping of the OMG Object Transaction Service (OTS) 1.1 Specification at the low-level.
 JTS uses the CORBA OTS interfaces for interopertability and portability.
 JSR - Java Community Process :)
--

== JTA vs. JTS

JTA is to JDBC as JTS is to the database driver

[NOTE.speaker]
--
 JTA and JTS
 The JTA is the interface developers use to manage transactions.
 The Java Transaction Service (JTS) is the Java language mapping of the CORBA OTS 1.1 Specification (Object Transaction Service) - defines how to propagate transactions between multiple JTS transaction managers.
 The Java Transaction Service (JTS), on the other hand, is an underlying transaction service that implements JTA.
 Think of the relationship between JTA and JTS as similar to the relationship between JDBC and the corresponding underlying database driver; JTA is to JDBC as JTS is to the database driver.
 JTS - used in CORBA where IIOP protocol to propagate transaction between multipe JTS TMs
--

== JTA and JBoss World

JTA is implemented by Narayana (Arjuna) Transaction manager

image:{images}/narayana-logo.png[]

== Where the transactions live

 * EJB - by default
 * CDI - `@Transactional`
 * When you want to touch it
 ** `@Resource/@Inject
    private UserTransaction utx;`
 ** `@Resource
    private SessionContext ctx;`
 ** `java:comp/UserTransaction`

== JTA API overview

 * UserTransaction
 * TransactionManager
 * Status
 * Transaction
 * Synchronization
 * TransactionSynchronizationRegistry
 * XAResource

[NOTE.speaker]
--
 UserTransaction for user
 TransactionManager for app server
 UserTransaction is mapped by spec to java:comp/UserTransaction jndi space
 TransactionManager is not specified where it resides
 If you want to add some synchronization then you need to take Transaction instance from TransactionManager :/
 Transaction instance means the transaction context in fact (flows from one bean to another)
--

= JPA

=== SQL table creation

[ source, language="sql" ]
----
 CREATE TABLE PERSON (
   id INTEGER NOT NULL DEFAULT ('person_seq'),
   username VARCHAR(255),
   birthdate DATE,
   ...
 )
----

[NOTE.speaker]
--
 PostgreSQL sequence: reate sequence person_seq increment 1 start 1;
--

=== Java entity definition

[ source, language="java" ]
----
 @Entity
 @Table("person")
 public class Person {
   @Id
   @GeneratedValue
   private int id;

   private String username;

   @Temporal(TemproalType.DATE)
   private Date birthDate;

   @ManyToMany
   @JoinTable(name = "PERSON_GROUP",
     joinColumn = @JoinColumn(name = "person_id"),
     inverseJoinColumn = @JoinColumn(name = "group_id"))
   private List<Groups> groups;

   ...
 }
----

=== Entity Manager

[ source, language="java" ]
----
 @Persisten
----

= EJB - BMT vs. CMT

[NOTE.speaker]
--
 TODO:
 Example of extended context from servlet to ejb and back
 SFSB has to be saved in session from webservlet (@Inject or old way)
 Does @Inject support to inject transaction?
 MDB and BMT
 JCA multiple datasources in XA
 JCA - Using tracking=true will make it scream... Assuming you are inside a transaction... WildFly doesn't make use of IronJacamar's tracking feature by default. Further details at http://www.ironjacamar.org/doc/roadto12/txtracking.html
 Asynchronous calls of EJB
 Transactions for EE batches
 JMS closing connection during the XA transaction - will be msg commited or not?

                <datasource jta="true" jndi-name="java:jboss/datasource-test" pool-name="datasource-test" enabled="true" use-java-context="true" spy="true">
                    <connection-url>jdbc:postgresql://localhost:5432/crashrec</connection-url>
                    <driver>database-jdbc-driver.jar</driver>
                    <security>
                        <user-name>crashrec</user-name>
                        <password>crashrec</password>
                    </security>
                </datasource>
                <xa-datasource jndi-name="java:jboss/xa-datasource-test" pool-name="xa-datasource-test" enabled="true" spy="true">
                    <xa-datasource-property name="PortNumber">
                        5432
                    </xa-datasource-property>
                    <xa-datasource-property name="ServerName">
                        localhost
                    </xa-datasource-property>
                    <xa-datasource-property name="DatabaseName">
                        crashrec
                    </xa-datasource-property>
                    <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>
                    <driver>database-jdbc-driver.jar</driver>
                    <security>
                        <user-name>crashrec</user-name>
                        <password>crashrec</password>
                    </security>
                </xa-datasource>
--

== References
 * Presentation https://github.com/ochaloup/ts-presentation
 * Java Transaction Design Strategies http://www.infoq.com/minibooks/JTDS
 * Transakce v Java EE (Kamil Ševeček) https://www.youtube.com/watch?v=6q9NIRBHd5I
 * Java Transaction Processing http://www.amazon.com/Java-Transaction-Processing-Design-Implementation/dp/013035290X

 * My bookmarks on http://delicious.com/chalda/ts.presentation

