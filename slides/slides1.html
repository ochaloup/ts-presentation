<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Ondra Chaloupka / ochaloup@redhat.com"><title>Transactions in Java</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.min.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme"><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script type="text/javascript">document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body>
           <img id="logo" src="reveal.js/lib/img/redhat-color-small.png" /><div class="reveal"><div class="slides"><section><h2>Transactions in Java</h2><p><small>Ondra Chaloupka / ochaloup@redhat.com</small></p></section><section id="_transactions_in_java"><h2>Transactions in Java ?</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">@Stateless
public class TestBean {

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void doWork() {
        // do something
    }
}</code></pre></div></div></section>
<section id="_transactions_in_java_2"><h2>Transactions in Java !?</h2><div class="paragraph"><p><span class="image"><img src="./misc/tagcloud.png" alt="tagcloud"></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Taken by http://www.wordle.net/create</pre></div></div></aside></section>
<section id="_agenda"><h2>Agenda</h2><div class="ulist"><ul><li><p>Terminology</p></li><li><p>Resource local transactions in Java SE</p><div class="ulist"><ul><li><p>Database</p></li><li><p>JMS</p></li></ul></div></li><li><p>Transactions in Java EE (on JBoss)</p><div class="ulist"><ul><li><p>Java Transaction API (JTA)</p></li><li><p>Java Persistence API (JPA)</p></li><li><p>Bean managed transactions (BMT)</p></li><li><p>Container managed transactions (CMT)</p></li></ul></div></li></ul></div></section>
<section id="_terminology_corner"><h2>Terminology corner</h2></section>
<section><section id="_a_transaction"><h2>A transaction</h2><div class="paragraph"><p>A transaction is a group of business logic statements with certain shared properties.</p></div><div class="paragraph"><p>Which are one or more of:</p></div><div class="paragraph"><p>Atomic, Consistent, Isolated, Durable</p></div><aside class="notes"><div class="literalblock"><div class="content"><pre>The statement above stolen from presentation of Michael Musgrove for Brno JBug, January 2015
From user point of view a transaction is an atomic unit of the work where everything or nothing is finished.
From developer point - we have some data and we want to save them to some store and if there is something
 running in paralel with our task we want to be isolated/warned from colisions.
All the presentation is about resources that could  be managed - resource is database, jms, mail service, whatever connected to JCA
Concurrency access is the main reason why we need to discuss such thing as transaction.
Transactions tries to make programmer's life easier to give him some assurances (zaruky)</pre></div></div></aside></section><section id="_acid"><h2>ACID</h2><div class="ulist"><ul><li><p>Atomicity</p></li><li><p>Consistency</p></li><li><p>Isolation</p></li><li><p>Durablitity</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>http://en.wikipedia.org/wiki/ACID, http://what-when-how.com/hibernate/transactions-and-concurrency-hibernate/
Atomicity
 * one part of transaction fails then whole transaction fails
 * the notion that all operations are executed as an atomic unit
Consistency
 * transaction will bring the database from one valid state to another according to defined rules (as constraints, cascades, triggers...)
 * by some definitions proclam that consistency should be maintained during the transaction execution as well (not only at transaction's ends)
   what I understand it's ok to say that transaction keeps consistency for short lived ACID isolated transactions. but if transaction does not guarantee
   isolation then the consistency inside of transaction run could be important or rather violated
 * consistency means that a transaction works on a consistent set of data: a set of data that is hidden from other concurrently running transactions
    and that is left in a clean and consistent state after the transactions completes
 * does not mean correctness of transaction from business point of view
Isolation
 * for transaction itself the system behaves like the paralel transactions would be run in serial order
 * concurrent execution of transactions results in a system state that would be obtained if transactions were executed serially (one by one)
Durablitity
 * durability means that once a transaction completes, all changes made during that transaction become persistent and arenâ€™t lost even if the system subsequently fails</pre></div></div></aside></section></section>
<section id="_other_transaction_types"><h2>Other transaction "types"</h2><div class="ulist"><ul><li><p>BA (Business Activities)</p></li><li><p>BTP</p></li><li><p>WS-CAF</p></li><li><p>WS-TX (WA-AT and WS-BA)</p></li><li><p>Extended transactions</p></li><li><p>BASE</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Resources
* https://www.youtube.com/watch?v=CR8_m5_k4fQ
* http://www.infoq.com/articles/History-of-Extended-Transactions
Extended transactions (in Narayana)
 * umbrella term for transaction systems/protocols which relax some of the ACID guarantees (properties)
 * from part of Narayana it's protocol based on Sagus (academic research from 1997)
 ** relaxes Isolation and Consistency (it's eventually consistent)
BA - business activities
 * BA is term from "another" world - in general it's long terming transaction (booking a flight + taxi from the airport)
 * came along with WebServices
BTP
 * Hewlett-Packard, Oracle and BEA worked on the OASIS Business Transaction Protocol (BTP), which was aimed at business-to-business transactions in loosely coupled domains such as Web Services
 * based on 2PC protocol in general
 * The specification developed two new models for "transactions", requiring business-level decisions to be incorporated within the transaction infrastructure
 * 2001
WS-CAF
 * ASIS Web Services Composite Application Framework (WS-CAF) TC (Defining an open framework for supporting coordinated and transactional compositions of multiple Web services applications)
 * 2006
WS-TX
 * ideas came from CORBA model (http://www.infoq.com/articles/History-of-Extended-Transactions)
 ** coordinator responsible for sending and receiving messages of arbitrary types - called signals
 ** coordinator inteligence - enabled for specific protocol with special sets of signals being transfered
 * WS-AT: atomic transactions - 2PC
 * WS-BA: businness activities doing compensation actions
BASE
 * ACID transaction doesn't scale
 * connected with the movement of NoSQL
 * came with CAP theorem - system could satisfy just two of these three requirements: Consistency, Availability, Parition Tolerance
 * one of the way how to handle CAP "trouble" is relaxing consistency which is where BASE goes
 ** Basic Availability -  spread data across many storage systems with a high degree of replication
 ** Soft State. - data consistency is the developer's problem and should not be handled by the database, consistency is not a goal here
 ** Eventual Consistency - system will eventually become consistent once it stops receiving input
 * some of the NoSQL databases tries to be ACID(like) -&gt; NewSQL - FoundationDB, NuoDB, OrientDB...</pre></div></div></aside></section>
<section id="_transaction_types"><h2>Transaction types</h2><div class="ulist"><ul><li><p>Top-level</p></li><li><p>Nested</p></li><li><p>Nested top-level</p></li><li><p>Concurrent nested</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Types
* Top-level transaction - transaction as we understand it
* Nested - transaction contains other transaction. When nested rollbacks it does not mean that top-one will rollback.
           If nested commits then the overall result depends on the top-level transaction.
* Nested top-level - nested is invoked in context of another txn but if top-level commits
                     it's commited independently on the outcome of the caller transaction.
* Concurrently running nested transaction - result has to be the same as they would be run in arbitrary serial order</pre></div></div></aside></section>
<section id="_transaction_types_contd"><h2>Transaction types (contd.)</h2><div class="ulist"><ul><li><p>Resource local</p></li><li><p>Global transaction</p></li><li><p>Distributed transaction</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Txn management
* Resource local - transaction at level of database or JMS server
* Global - transaction "consisting" from several resource local transactions managed by transaction manager
* Distributed transaction - transaction spread over multiple transaction managers</pre></div></div></aside></section>
<section id="_xa_vs_distributed_transaction"><h2>XA vs. Distributed transaction</h2><div class="ulist"><ul><li><p>XA - XA/Open XA architecture - multiple resources</p></li><li><p>Distributed - multiple transaction managers</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>In many sources under term distributed transaction means XA from point of view of this presentation (and Narayana TM in general.
E.g. JDBC specification talks about distributed transactions but such txn means XA transaction from point of view of this presentation.
Narayna/JBoss/EAP point of view understands distributed transactions such ones that pass its context over a to a different transaction manager.
XA transaction is such that contains several resources, such specified by X/Open XA architecture - meaning transaction using 2PC protocol over more resources.
This presentation won't be about neither XA or distributed transactions (maybe about distributed in sense of context passing between EJB beans)</pre></div></div></aside></section>
<section id="_transactions_from_developer_point_of_view"><h2>Transactions from developer point of view</h2><div class="ulist"><ul><li><p>Local transaction model
<code class="stretch">connection.commit</code></p></li><li><p>Programmatic transaction model
<code class="stretch">transaction.commit()</code></p></li><li><p>Declarative transaction model
<code class="stretch">@TransactionAttribute(TransactionAttributeType.REQUIRED)</code></p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Local - working directly with resource/connection</p></li><li><p>Programmatic - not working with resource but with a transaction</p></li><li><p>Declarative - transactions are hidden behind of JEE layer</p></li></ul></div></aside></section>
<section id="_databases_and_jdbc"><h2>Databases and JDBC</h2></section>
<section id="_database_transaction"><h2>Database transaction</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch sql language-sql">BEGIN;
INSERT INTO test_table VALUES (1, 'test');
COMMIT;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>PostgreSQL "syntax"</pre></div></div></aside></section>
<section id="_isolation_level"><h2>Isolation level</h2><div class="paragraph"><p><span class="image"><img src="./misc/db/isolation-levels-base.png" alt="isolation-levels-base"></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Resources
  * http://what-when-how.com/hibernate/transactions-and-concurrency-hibernate/#bookmark369
  * Java Transaction Design Strategy p53
It's interaction of interleaving transactions
Transaction isolation is a function of database cocurrency and database consistency - more isolation, means more consistency but less concurrency
Hibernate increase level of isolation to moving control to application layer
 * optimistic locking adds versioning and so non-repeatable reads can't occur - meaning repeatable read isolation level is supported
    (or the special case when second commit replaces data of first commit)
 * pesimistic locking uses SELECT ... FOR UPDATE to lock particular record in database - this is other way how support read isolation level
    but it's hard support as the concurrent user has to wait till previous transaction will not release the resource</pre></div></div></aside></section>
<section id="_lost_update"><h2>Lost update</h2><div class="paragraph"><p><span class="image"><img src="./misc/db/01-lost-update.jpg" alt="01-lost-update"></span></p></div>
<div class="paragraph"><p><span class="small">shamelessly stolen from <a href="http://what-when-how.com" class="bare">http://what-when-how.com</a></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>two transactions doing update in parallel but first does commit and second rollbacks - then the commit of first willl be lost</pre></div></div></aside></section>
<section id="_dirty_reads"><h2>Dirty reads</h2><div class="paragraph"><p><span class="image"><img src="./misc/db/02-dirty-reads.jpg" alt="02-dirty-reads"></span></p></div>
<div class="paragraph"><p><span class="small">shamelessly stolen from <a href="http://what-when-how.com" class="bare">http://what-when-how.com</a></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>two transactions running in paralel. first does update and second shortly after that reads the same data - the update will be wisible
despite the fact that the first transaction is rollbacked in a while</pre></div></div></aside></section>
<section id="_non_repeatable_reads"><h2>Non-repeatable reads</h2><div class="paragraph"><p><span class="image"><img src="./misc/db/03-non-repeatable-reads.jpg" alt="03-non-repeatable-reads"></span></p></div>
<div class="paragraph"><p><span class="small">shamelessly stolen from <a href="http://what-when-how.com" class="bare">http://what-when-how.com</a></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>when first transaction does two reads of some data already saved! in transaction - one after another - and between these two actions second transaction does commit
the second read of the first transaction will get another data then the first read</pre></div></div></aside></section>
<section id="_phantom_reads"><h2>Phantom reads</h2><div class="paragraph"><p><span class="image"><img src="./misc/db/04-phantom-reads.jpg" alt="04-phantom-reads"></span></p></div>
<div class="paragraph"><p><span class="small">shamelessly stolen from <a href="http://what-when-how.com" class="bare">http://what-when-how.com</a></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>when transaction does select over more rows it could reads different count of rows in two subsequent queries when another transaction was meanwhile commited and
added a row which is contained in the searched query</pre></div></div></aside></section>
<section id="_quiz"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">java.sql.Connection connection = DriverManager.getConnection(...)
Statement st = connection.createStatement();
st.execute("INSERT INTO table VALUES (1, 'EAP QE')");</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Where is the transaction?</pre></div></div></aside></section>
<section id="_quiz_answer"><h2>Quiz - Answer</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">java.sql.Connection connection = DriverManager.getConnection(...)
connection.setAutoCommit(false);
Statement st = connection.createStatement();
st.execute("INSERT INTO table VALUES (1, 'EAP QE')");
connection.commit();</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>The autocommit mode on connection was used. The update was reflected in database immediatelly when statement was executed.
In this answer slide the update is reflected after commit is called - the transaction was explicitly stated by setAutoCommit(false)</pre></div></div></aside></section>
<section id="_jdbc"><h2>JDBC</h2><div class="ulist"><ul><li><p>Connection.setAutoCommit</p></li><li><p>Connection.setTransactionIsolation</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>transactions are managed by Connection.setAutoCommit method</p></li></ul></div></aside></section>
<section id="_jdbc_batch"><h2>JDBC batch</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">java.sql.Connection connection = DriverManager.getConnection(...)
connection.setAutoCommit(false);
Statement st = connection.createStatement();
st.addBatch("INSERT INTO table VALUES (1, 'JTA')");
st.addBatch("INSERT INTO table VALUES (2, 'JCA')");
int[] updateCounts = st.executeBatch();
connection.commit();</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Some performance optimalizations for batching could be taken by database.
But from test log there is no any special handling for simple cases as this one.
There are just two inserts one after another.
Butch return simple count of changes. It can't return ResultSet.</pre></div></div></aside></section>
<section id="_jdbc_nested_transactions"><h2>JDBC "nested" transactions</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">java.sql.Connection connection = DriverManager.getConnection(...)
connection.setAutoCommit(false);
Statement st = connection.createStatement();
st.execute("INSERT INTO table VALUES (1, 'EAP 6')");
Savepoint savePoint = connection.setSavepoint();
st.execute("UPDATE table SET product='EAP 7' WHERE id=1");
connection.rollback(savePoint);
connection.commit();</code></pre></div></div></section>
<section id="_be_aware_of_ddl_commands"><h2>Be aware of DDL commands</h2><div class="ulist"><ul><li><p>DDL - data definition language (CREATE, DROP&#8230;&#8203;)</p></li><li><p>DML - data manipulation language (INSERT, UPDATE&#8230;&#8203;)</p></li><li><p>lot of Databases does not support transactional DDL</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Resource:
 <a href="https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis" class="bare">https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis</a>
 PostgreSQL do DDL in transaction
 e.g. Oracle (probably - not up-to-date info) first commits currently running DML and then does DDL in separate transaction</p></div></aside></section>
<section id="_jms"><h2>JMS</h2></section>
<section id="_transactions_and_redelivery"><h2>Transactions and redelivery</h2><div class="paragraph"><p><span class="image"><img src="./misc/jms/jms-transaction-redelivery.png" alt="jms-transaction-redelivery"></span></p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Resources: http://www.javaworld.com/article/2074123/java-web-development/transaction-and-redelivery-in-jms.html
First - simplifiyng abilities of JMS
Second - aim is that we want being safe thta message was really delivered
* if message waits in queue (in JMS provider) then the its fate in case of failure depends on delivery mode: *persistent* or *nonpersistent*
** HornetQ settings: &lt;persistence-enabled&gt;true&lt;/persistence-enabled&gt;
* if message is being sent then acknowledgement that was received is driven by by transaction/redelivery modes
* all this is set when *Session* is created</pre></div></div></aside></section>
<section id="_session_creation"><h2>Session creation</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">Connection.createSession(boolean transacted, int acknowledgeMode)</code></pre></div></div>
<div class="ulist"><ul><li><p><code class="stretch">Session.AUTO_ACKNOWLEDGE</code></p></li><li><p><code>Session.DUPS_OK_ACKNOWLEDGE</code></p></li><li><p><code>Session.CLIENT_ACKNOWLEDGE</code></p></li><li><p><code>Session.SESSION_TRANSACTED</code></p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>If session is set as transacted = true then acknowledgeMode is ignored
Or at least it should be - this is not true for Genereic JMS RA (Tibco and EAP)
* commit() is called on Session (transacted=true)
* acknowledge() is called Message (transacted=false, acknowledgeMode=CLIENT_ACKNOWLEDGE)
AUTO - If a failure occurs while executing the receive() method or the onMessage() method, the message is automatically redelivered.
       The JMS provider carefully manages message redelivery and guarantees once-only delivery semantics.
DUPS - With less overhead than auto mode, in duplicates okay mode, the JMS provider guarantees at-least-once message delivery.
       During failure recovery, certain messages are probably delivered more than once.
CLIENT - In client mode, invoking the Message class's acknowledge() method explicitly acknowledges the message.
         In fact, using the acknowledge() method makes sense when only using the client mode.</pre></div></div></aside></section>
<section id="_quiz_2"><h2>Quiz</h2><div class="paragraph"><p>What happens on JMS transaction rollback?</p></div></section>
<section id="_quiz_answer_2"><h2>Quiz - Answer</h2><div class="ulist"><ul><li><p>automatic redelivery rollbacked messages</p></li><li><p>redelivery count could be defined</p></li><li><p>redelivery timeout could be defined</p></li><li><p>exceptional destination (message is non-deliverable)</p><div class="ulist"><ul><li><p>message is only logged</p></li><li><p>message is forwarded to an error destination</p></li><li><p>message is forgotten</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>redelivery count - number of tries to deliver message, redelivery count is important as not deliverable messages can eventually crash the system
redelivery timeout - time to wait before redelivering the message. This delay lets the JMS provider and the application recover to a stable state.
when rollback it could be set whether rollbacked message goes to the end or to the front of the queue - it depends on some config etc.</pre></div></div></aside></section>
<section id="_java_ee"><h2>Java EE</h2><aside class="notes"><div class="literalblock"><div class="content"><pre>When speaking about Transaction manager then Narayana/Arjuna is meant
When speaking about appliation server then JBoss EAP/Wildfly is meant</pre></div></div></aside></section>
<section id="_jboss_sources_configuration"><h2>JBoss sources configuration</h2></section>
<section id="_datasource"><h2>Datasource</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">  &lt;datasource jta="true" jndi-name="java:jboss/datasource-test" pool-name="datasource-test" enabled="true" use-java-context="true" spy="true"&gt;
      &lt;connection-url&gt;jdbc:postgresql://localhost:5432/crashrec&lt;/connection-url&gt;
      &lt;driver&gt;database-jdbc-driver.jar&lt;/driver&gt;
      &lt;security&gt;
          &lt;user-name&gt;crashrec&lt;/user-name&gt;
          &lt;password&gt;crashrec&lt;/password&gt;
      &lt;/security&gt;
      &lt;transaction-isolation&gt;TRANSACTION_READ_COMMITTED&lt;/transaction-isolation&gt;
  &lt;/datasource&gt;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Note datasource attribute jta here which could be true/false - jta datasource or non-jta datasource</pre></div></div></aside></section>
<section id="_xa_datasource"><h2>XA Datasource</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">  &lt;xa-datasource jndi-name="java:jboss/xa-datasource-test" pool-name="xa-datasource-test" enabled="true" spy="true"&gt;
      &lt;xa-datasource-property name="PortNumber"&gt;
          5432
      &lt;/xa-datasource-property&gt;
      &lt;xa-datasource-property name="ServerName"&gt;
          localhost
      &lt;/xa-datasource-property&gt;
      &lt;xa-datasource-property name="DatabaseName"&gt;
          crashrec
      &lt;/xa-datasource-property&gt;
      &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
      &lt;driver&gt;database-jdbc-driver.jar&lt;/driver&gt;
      &lt;security&gt;
          &lt;user-name&gt;crashrec&lt;/user-name&gt;
          &lt;password&gt;crashrec&lt;/password&gt;
      &lt;/security&gt;
  &lt;/xa-datasource&gt;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>From testing point of view where different databases are used is necessary to know which xa-datasource-property is used
in what jdbc driver (e.g. Oracle understand the URL property which is jdbc url and no other database does so)</pre></div></div></aside></section>
<section id="_jms_configuration_hornetq"><h2>JMS configuration (HornetQ)</h2><div class="literalblock"><div class="content"><pre>See standalone-full.xml</pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Messaging is configured only in -full profiles</pre></div></div></aside></section>
<section id="_jta"><h2>JTA</h2><aside class="notes"><div class="literalblock"><div class="content"><pre>TODO: Ideas to check:
 * nested transactions
 * JTS and Corba - how to use it</pre></div></div></aside></section>
<section id="_quiz_3"><h2>Quiz</h2><div class="paragraph"><p>What is the JTA/Transaction Manager for?</p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>We know that we can manage database or jms resource directly why such thing is not
covered by Java EE container and we need some specification of transaction?
What that transaction for?
What the JTA could offer to me?</pre></div></div></aside></section>
<section id="_quiz_answer_3"><h2>Quiz - Answer</h2><div class="ulist"><ul><li><p>Managing transactions :)</p><div class="ulist"><ul><li><p>High-level API that allows application and application server to demarcate transaction boundaries</p></li></ul></div></li><li><p>Machinery of two phase commit protocol</p><div class="ulist"><ul><li><p>Java mapping of X/Open XA protocol</p></li></ul></div></li><li><p>Local managers are not thread safe</p></li><li><p>Recovery management</p></li><li><p>Timeout setting</p></li><li><p>Rollback-only behaviour setting</p></li><li><p>Distributed transactions</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>It's standardized way how container can communicate with transaction.
Specialized thread (in background or foreground) which is able to stop running transaction after specified amount of time.
It's way how more then one resource could be part of one ACID transaction (DB + JMS + Mail service create one txn)
setRollbackOnly() - this know to do EntityTransaction as well but it's just for one resource
Transaction is tread safe as the Transaction uses java `ThreadLocal` type</pre></div></div></aside></section>
<section id="_jta_a_bit_on_history"><h2>JTA a bit on history</h2><div class="ulist"><ul><li><p>Implementation of X/Open XA architecture (JSR 907)</p></li><li><p>Versions</p><div class="ulist"><ul><li><p>1.0 - year 2000</p></li><li><p>1.1 - year 2007 (EE 5)</p></li><li><p>1.2 - year 2013 (EE 7)</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Java Transaction API ensures that we can use XA transactions (2PC)
* X/Open XA - open group for distributed transaction processing (DTP)
* 1.0 - All the stuff (UserTransaction)
* 1.1 - TransactionSynchronizationRegistry - used by component like JPA to registry in order and being able to manage transaction on the registred hook
* 1.2 - @Transactional, @TransactionScoped - ripping transaction of the EJB (with CDI to CDI beans, Servlet, JAX-RS...)</pre></div></div></aside></section>
<section id="_specifications_a_bit_messy"><h2>Specifications - a bit messy</h2><div class="ulist"><ul><li><p>JTA (JSR 907) maps XA spec to Java</p></li><li><p>XA spec from year 1991 by The Open Group</p></li><li><p>JTS spec maps OTS spec to Java</p></li><li><p>OTS spec by Object management Group (OMG)</p></li><li><p>JCA, JMS, JDBC, EJB contains sections about transactions</p></li><li><p>WS-AT and WS-BA under OASIS standard</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>There is no central place with information about transactions in Java
JTS specifies the implementation of a transaction manager which supports the JTA specification at the high-level and implements the Java mapping of the OMG Object Transaction Service (OTS) 1.1 Specification at the low-level.
JTS uses the CORBA OTS interfaces for interopertability and portability.
JSR - Java Community Process :)</pre></div></div></aside></section>
<section id="_implementations"><h2>Implementations</h2><div class="literalblock"><div class="content"><pre>*Transaction Manager*</pre></div></div>
<div class="ulist"><ul><li><p>Narayana JBoss TM (Arjuna formerly)</p></li><li><p>Atomikos</p></li><li><p>Bitronix</p></li><li><p>Glassfish reference implementation</p></li><li><p>&#8230;&#8203;</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="./misc/narayana-logo.png" alt="narayana-logo"></span></p></div></section>
<section id="_jta_vs_jts"><h2>JTA vs. JTS</h2><div class="paragraph"><p>Difference of JTA and JTS has some parallel in difference JDBC to the database driver.</p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>JTA is higher level api which uses application server, JTS is internal (low-level) api of TM how to communicate and manage transactional context.
The JTA is the interface developers use to manage transactions.
The Java Transaction Service (JTS) is the Java language mapping of the CORBA OTS 1.1 Specification (Object Transaction Service) - defines how to propagate transactions between multiple JTS transaction managers.
The Java Transaction Service (JTS), on the other hand, is an underlying transaction service that implements JTA.
Think of the relationship between JTA and JTS as similar to the relationship between JDBC and the corresponding underlying database driver; JTA is to JDBC as JTS is to the database driver.
JTS - used in CORBA where IIOP protocol to propagate transaction between multipe JTS TMs</pre></div></div>
<div class="literalblock"><div class="content"><pre>JTA is to JDBC as JTS is to the database driver</pre></div></div></aside></section>
<section id="_jta_api_overview"><h2>JTA API overview</h2><div class="ulist"><ul><li><p>UserTransaction</p></li><li><p>TransactionManager</p></li><li><p>Status</p></li><li><p>Transaction</p></li><li><p>Synchronization</p></li><li><p>TransactionSynchronizationRegistry</p></li><li><p>XAResource</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>UserTransaction for user
TransactionManager for app server
UserTransaction is mapped by spec to java:comp/UserTransaction jndi space
TransactionManager is not specified where it resides
If you want to add some synchronization then you need to take Transaction instance from TransactionManager :/
Transaction instance means the transaction context in fact (flows from one bean to another)</pre></div></div></aside></section>
<section id="_jpa"><h2>JPA</h2></section>
<section><section id="_jpa_overview_in_short"><h2>JPA overview in short</h2><div class="ulist"><ul><li><p>ORM (Object-relational mapping)</p></li><li><p>EclipseLink (reference), Hibernate (JBoss)</p></li><li><p>Benefits (theoretically)</p><div class="ulist"><ul><li><p>staying in object oriented world</p></li><li><p>independent on underlaying database</p></li><li><p>simplified CRUD</p></li><li><p>JPQL (db independent + simplified join queries)</p></li><li><p>automatic table creation (hbm2dll)</p></li><li><p>performance (lazy dml, batching sql, 2nd level cache)</p></li></ul></div></li></ul></div><aside class="notes"><div class="literalblock"><div class="content"><pre>Resource: http://www.javatpoint.com/hibernate-tutorial, http://www.journaldev.com/2882/hibernate-tutorial-for-beginners-using-xml-annotations-and-property-configurations</pre></div></div></aside></section><section id="_sql_table_creation"><h2>SQL table creation</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch sql language-sql"> CREATE TABLE PERSON (
   id INTEGER NOT NULL DEFAULT ('person_seq'),
   username VARCHAR(255),
   birthdate DATE,
   ...
 )</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>PostgreSQL sequence: reate sequence person_seq increment 1 start 1;</pre></div></div></aside></section><section id="_java_entity_definition"><h2>Java entity definition</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Entity
 @Table("person")
 public class Person {
   @Id
   @GeneratedValue
   private int id;

   private String username;

   @Temporal(TemproalType.DATE)
   private Date birthDate;

   @ManyToMany
   @JoinTable(name = "PERSON_GROUP",
     joinColumn = @JoinColumn(name = "person_id"),
     inverseJoinColumn = @JoinColumn(name = "group_id"))
   private List&lt;Groups&gt; groups;

   ...
 }</code></pre></div></div></section><section id="_entity_manager_in_java_se"><h2>Entity Manager in Java SE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> EntityManagerFactory emf = Persistence.createEntityManagerFactory("MyPersistenceUnit");
 EntityManager em = emf.createEntityManager();

 em.getTransaction().begin();

 Person person = new Person();
 person.setName("JBoss EAP 6");

 em.persist(person);

 em.getTransaction().commit();

 em.close();
 emf.close();</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>TODO: I haven't found a way how to not use a transaction for persist action will be reflected in database.
      Setting autoCommit to true in persistence.xml does not help in this (at least for RESOURCE_LOCAL)
      I think that autoCommit settings is used for JPA when TransactionAttribute NOT_SUPPORTED is used.
em.getTranaction() is type of EntityTransaction
em.clear() - clear persistence context</pre></div></div></aside></section><section id="_entity_manager_in_java_ee"><h2>Entity Manager in Java EE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public SomeBean() {
   @PersistenceContext
   EntityManager em;

   public void newPerson() {
     Person person = new Person();
     person.setName("JBoss EAP 6");
     em.persist(person);
   }
 }</code></pre></div></div></section><section id="_persistence_xml_in_java_se"><h2>Persistence.xml in Java SE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch xml language-xml">  &lt;persistence-unit name="ResourceLocalPersistenceUnit" transaction-type="RESOURCE_LOCAL"&gt;
      &lt;class&gt;org.jboss.qa.tspresentation.Person&lt;/class&gt;

      &lt;properties&gt;
          &lt;property name="hibernate.connection.url" value="jdbc:postgresql://localhost:5432/crashrec?loglevel=2"/&gt;
          &lt;!-- &lt;property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQL82Dialect"/&gt;  --&gt;
          &lt;property name="hibernate.connection.driver_class" value="org.postgresql.Driver"/&gt;
          &lt;property name="hibernate.connection.username" value="crashrec"/&gt;
          &lt;property name="hibernate.connection.password" value="crashrec"/&gt;

          &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;

          &lt;property name="hibernate.show_sql" value="true"/&gt;
          &lt;property name="hibernate.format_sql" value="true"/&gt;
      &lt;/properties&gt;
  &lt;/persistence-unit&gt;</code></pre></div></div></section><section id="_persistence_xml_in_java_ee"><h2>Persistence.xml in Java EE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch xml language-xml"> &lt;persistence-unit name="TestPersistenceUnit" transaction-type="JTA"&gt;
      &lt;jta-data-source&gt;java:jboss/datasource-test&lt;/jta-data-source&gt;

      &lt;properties&gt;
          &lt;property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQL82Dialect"/&gt;
          &lt;property name="hibernate.temp.use_jdbc_metadata_defaults" value="true" /&gt;

          &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;

          &lt;property name="hibernate.show_sql" value="true"/&gt;
          &lt;property name="hibernate.format_sql" value="true"/&gt;
      &lt;/properties&gt;
  &lt;/persistence-unit&gt;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>What I understand when I define dialect and use hibernate.temp.use_jdbc_metadata_defaults then Hibernate does not need to ask for metatadata
from the database and there are not done some first quering of database
Beside jta-data-source there is tag non-jta-data-source bug JBoss(WildFly 8.2) does not respect this and it only depends what is underlayin datasource
if datasource is jta=false then it always (doesn't matter what is tag for) used as non-transactional from TM point of view (autocommit=true)
if datasource is jta=true then it's joint to global TM if exists</pre></div></div></aside></section></section>
<section id="_em_flush_and_em_clear"><h2>em.flush() and em.clear()</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java">  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin();
  Person person = em.find(Person.java, 1L);
  person.setName("JBoss EAP 7");
  // em.flush()
  em.getTransaction().commit();

  em.clear();</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>EntityManager instance is 1st level cache. It contains all data that we used and it run SQLs to update database
just if it' necessary (it's lazy DML)
* em.flush()
* em.close() (application managed and extended-scoped pc)
* on commit transaction
* when using query and some entities are dirty
* driven by FlushModeType
** AUTO as stated above (default)
** COMMIT only on transaction commit (queries could get stale data)
Hibernate implementation does add MANUAL, NEVER, ALWAYS, PERSISTENCE_CONTEXT... see javadoc</pre></div></div>
<div class="literalblock"><div class="content"><pre>in Java EE em.clear() is called at the end of transaction
in Java SE the context (entity manager) is not cleared and it's up to developer when it should be cleared
  if context is full of data we can do some change of one particular item/record/entity and all other data
  which we don't know about their existence could be published to database simultaneouslly</pre></div></div>
<div class="literalblock"><div class="content"><pre>after clear() is called (or em is closed) the entities are detached and for the next usage it's need to
be attached to some entity manager (persitence context) by em.merge(entity_instance)</pre></div></div></aside></section>
<section id="_transactions_in_jpa"><h2>Transactions in JPA</h2><div class="ulist"><ul><li><p>Transaction management defined by transaction-type (persistence.xml)</p></li><li><p>Connected with persistence context type</p></li><li><p>Any update operation has to be proceeded inside of a transaction</p></li><li><p>Read operation could be proceeded out of the transaction</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>In Java SE working with EntityTransaction, in Java EE with global transaction. It's problematic to use autocommit=true.
In fact autocommit=true is probably (!) used when NOT_SUPPORTED for transaction is used. For Java SE it's probably(!) necessary
to directly touch underlaying connection as normally EntityTransaction has to be started and it's not possible to change it by some
easily accesible settings or API.</pre></div></div>
<div class="literalblock"><div class="content"><pre>NOTE: all this tested on PostgreSQL</pre></div></div></aside></section>
<section id="_persistence_context_types"><h2>Persistence context types</h2><div class="ulist"><ul><li><p>Application-managed</p><div class="ulist"><ul><li><p>RESOURCE_LOCAL/Java SE</p></li><li><p>ends (is cleared) on manual call of clear method or em.remove(entity)</p></li></ul></div></li><li><p>Container-managed Transaction-scoped</p><div class="ulist"><ul><li><p>ends at the end of transaction</p></li></ul></div></li><li><p>Container-managed Extended</p><div class="ulist"><ul><li><p>used only with SFSB</p></li><li><p>ends when SFSB method <code class="stretch">@Remove</code> is called</p></li><li><p>during the time several transactions could be committed</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Java SE is not precondition here but it's standard to do it so. The application managed is more bound to
transaction-type attribute where here it's resource local</pre></div></div>
<div class="literalblock"><div class="content"><pre>Persistence context type is set by @PersistenceContext annotation and types like PersistenceContextType.TRANSACTION (default)
and PersistenceContextType.EXTENDED</pre></div></div>
<div class="literalblock"><div class="content"><pre>When persitence context ends then it's flushed and cleared = all entities started to be detached</pre></div></div></aside></section>
<section id="_a_side_note_locking"><h2>A side note: locking</h2><div class="ulist"><ul><li><p>Optimistic</p><div class="ulist"><ul><li><p><code class="stretch">@Version</code> at attribute</p></li><li><p><code>em.lock(person, LockModeType.OPTIMISTIC)</code></p></li></ul></div></li><li><p>Pesimistic</p><div class="ulist"><ul><li><p><code>em.lock(persion, LockModeType.PESIMISTIC_WRITE)</code></p></li></ul></div></li></ul></div></section>
<section id="_transactions_in_application_server"><h2>Transactions in Application Server</h2><aside class="notes"><div class="literalblock"><div class="content"><pre>TODO:
JMS closing connection during the XA transaction - will be msg commited or not?</pre></div></div></aside></section>
<section id="_how_to_get_the_method_being_transactional"><h2>How to get the method being transactional</h2><div class="ulist"><ul><li><p>EJB method is transactional by default</p></li><li><p>CDI - <code class="stretch">@Transactional</code></p></li><li><p>To get it</p><div class="ulist"><ul><li><p><code>@Resource/@Inject UserTransaction utx;</code></p></li><li><p><code>@Resource SessionContext ctx;</code></p></li><li><p><code>java:comp/UserTransaction</code></p></li><li><p><code>java:jboss/TransactionManager</code></p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>There could be one difference in @Resource and @Inject. WildFly checks whether @Resource annotation is used in EJB sesion or message driven bean when bean demarcation is specified.
UserTransaction is not permitted to be used in any other location (EjbExeption - IllegalStateException -JBAS011048: Failed to construct component instance)
You can't access UserTransaction interface either with use of SessionContext when you are not in bean managed demarcation (WildFly 8.2)
But by @Inject you can inject transaction in whatever location you want in general.
@Resource could be used in Servlet.</pre></div></div>
<div class="literalblock"><div class="content"><pre>Jndi for user transaction is defined by spec. Jndi for transaction manager is container specific.</pre></div></div></aside></section>
<section id="_ejb_bean_managed_transactions"><h2>EJB Bean-managed transactions</h2><aside class="notes"><div class="literalblock"><div class="content"><pre>Either in BMT or CMT we still touches global transaction managed by transaction manager. That's important to understand.
Programatic approach</pre></div></div></aside></section>
<section id="_bean_managed_transaction"><h2>Bean-managed transaction</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Resource
 SessionContext ctx;

 public void method(){
   try {
      UserTransaction utx = ctx.getUserTransaction();
      utx.begin();
      ...
      utx.commit();
   } catch(Exception e) {
      utx.rollback();
   }
 }</code></pre></div></div></section>
<section id="_limitation_of_usage"><h2>Limitation of usage</h2><div class="ulist"><ul><li><p>Session beans (@Stateful, @Stateless, @Singleton)</p></li><li><p>Message driven beans (@MessageDriven)</p></li><li><p>Entity bean (EJB 2.0) can only be CMT</p></li><li><p>Stateful beans can&#8217;t use SessionSynchronization</p></li></ul></div></section>
<section id="_quiz_4"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method(){
     try {
        utx.begin();
        ...
        // utx.commit(); &lt;---
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>A bit tricky :) here. Session bean is CONTAINER managed by default.
This will throw an EJBException</pre></div></div></aside></section>
<section id="_quiz_5"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method() {
     try {
        utx.begin();
        ...
        // utx.commit(); &lt;---
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_quiz_contd"><h2>Quiz (contd.)</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateful
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method() {
     try {
        utx.begin();
        ...
        // utx.commit(); &lt;---
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_quiz_answer_4"><h2>Quiz - Answer</h2><div class="ulist"><ul><li><p>Stateless, Singleton, MDB: EJB container ensures that transaction won&#8217;t leave a method uncommitted</p><div class="ulist"><ul><li><p>EJBException ("should complete transaction before returning") + rollback done by container</p></li></ul></div></li><li><p>Stateful: transaction can flow over several method invocations on the same SFSB instance</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Limitation of @Stateless bean to commit transaction came from the fact (probably) that nested transactions
are not supported by JTA (&lt;- really not sure with this statement)</pre></div></div>
<div class="literalblock"><div class="content"><pre>For stateful bean the transaction could be span e.g. over several http calls.</pre></div></div></aside></section>
<section id="_quiz_6"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method() {
     try {
        utx.begin();
        utx.setTransactionTimeout(30); // seconds
        ...
        utx.commit();
     } catch(Exception e) {
        ut.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_quiz_answer_5"><h2>Quiz - Answer</h2><div class="literalblock"><div class="content"><pre>Nothing will happen. Transaction timeout has to be set before transaction is started.</pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Default jboss transaction timeout is 5 minutes (default-timeout of transactions subsystem).</pre></div></div></aside></section>
<section id="_exception_handling"><h2>Exception handling</h2><div class="literalblock"><div class="content"><pre>In difference from CMT you need to handled it on your own (at least partly).</pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>When RuntimeException is thrown from another bean - ie. when setRollbackOnly flag is set then then transaction can't be commited.
When you run commit you got Throwable and when you catch it and try to rollback then you get EJBException - no transaction!
But in fact transaction seems to be really rollbacked. So some automatic handling is available.</pre></div></div></aside></section>
<section id="_message_driven_bean"><h2>Message Driven Bean</h2><div class="ulist"><ul><li><p>transaction context does not flow with a JMS message</p></li><li><p>handled by JCA in-flow protocol</p></li><li><p>Bean managed transaction</p><div class="ulist"><ul><li><p>message receive is not part of tranaction</p></li><li><p>you can start new transaction inside of onMessage method but received message is already acknowledged</p></li></ul></div></li><li><p>Container managed transaction</p><div class="ulist"><ul><li><p>REQUIRED - new transaction at onMessage method start</p></li><li><p>NOT_SUPPORTED - no transaction - acknowledge mode</p></li></ul></div></li></ul></div></section>
<section id="_ejb_container_managed_transactions"><h2>EJB Container-managed transactions</h2><aside class="notes"><div class="literalblock"><div class="content"><pre>Declarative approach</pre></div></div></aside></section>
<section id="_annotations_under_use"><h2>Annotations under use</h2><div class="ulist"><ul><li><p>@TransactionManagement</p></li><li><p>@TransactionAttribute</p></li><li><p>@TransactionTimeout</p></li><li><p>@ApplicationException</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>@TransactionManagement - CONTAINER, BEAN (container is by default)
@TransactionAttribute - REQUIRED, REQUIRES_NEW... (required is by default)
@TransactionTimeout is jboss specific annotation - not part of EJB spec
@ApplicationException is put to user exception (standard or runtime) and defines if such exception should cause the rollback or not
  (RuntimeException could be marked for not causing the rollback)</pre></div></div>
<div class="literalblock"><div class="content"><pre>Each method is associated with *one* transaction. Neither nested or multiple transactions are not permitted.</pre></div></div></aside></section>
<section id="_transaction_attributes"><h2>Transaction attributes</h2><div class="ulist"><ul><li><p>REQUIRED</p></li><li><p>REQUIRES_NEW</p></li><li><p>MANDATORY</p></li><li><p>NOT_SUPPORTED</p></li><li><p>SUPPORTS</p></li><li><p>NEVER</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Resource: http://entjavastuff.blogspot.cz/2011/02/ejb-transaction-management-going-deeper.html
Attributes
* REQUIRED - no txn then new transaction is started or joining to existing txn
* REQUIRES_NEW - new transaction is started anytime
   - outer transaction is put to sleep until the inner EJB call finishes
   - note that the inner transaction does not share the managed entities of the outer transaction, they are completely isolated
* MANDATORY - no txn then EjbTransactionRequiredException or joining the existing txn
  - powerful tool that can help you to make your transactional code so much more robust - e.g. mark storage DAO methods that accept (managed) entities as a parameter as MANDATORY
* NOT_SUPPORTED - method runs without transaction anytime (no txn then nothing is done or suspend running txn)
  What could be useful for:
  - documentation. The annotation instantly tells you that the method does nothing transactional.
  - resources. There is always a cost in managing a transaction, so if the container doesn't have to, give it a break.
  - decreased whoops factor.  you'll catch transaction mistakes far sooner in your development cycle
* SUPPORTS - no txn then nothing is done (method runs without txn) or joining the existing txn
   - container is lazy :)
* NEVER - no txn then nothing is done (method runs without txn) or EJBException if calling method propagates some started txn
   - can be a useful tool to catch programming mistakes early on
   - when you make a call to another EJB, that EJB may safely create its own isolated transaction - NEVER may actually become a performance hog because of many mini-transactions being created</pre></div></div>
<div class="literalblock"><div class="content"><pre>When there is not transaction context active (ie. NOT_SUPPORTED) then for JMS autoack should be used and for database autoCommit is true.</pre></div></div></aside></section>
<section id="_easy_peasy"><h2>Easy peasy</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 // @TransactionAttribute(TransactionAttributeType.REQUIRED)
 public class MyBean {
    public void method() {
        // work with application managed resource
        // working directly with a database connection or
        // jms session won't bring you any transactional advantages
    }
 }</code></pre></div></div></section>
<section id="_quiz_7"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class MyBean {

    public void createNewUser(String name) {
      UserEntity user = new UserEntity(name);
      em.persist(user);

      long numberOfUsersBeforeCommit = getNumberOfUsers();
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public long getNumberOfUsers() {
      String sql = "SELECT COUNT(u.id) FROM UserEntity u";
      Query q = em.createQuery(sql);
      return (long) q.getSingleResult();
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Will the getNumberOfUsers know about newly created entity user from createNewUser?</pre></div></div></aside></section>
<section id="_quiz_answer_6"><h2>Quiz - Answer</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class MyBean {
    @EJB
    private MyBean thisBean;

    public void createNewUser(String name) {
      UserEntity user = new UserEntity(name);
      em.persist(user);

      long numberOfUsersBeforeCommit = thisBean.getNumberOfUsers();
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public long getNumberOfUsers() {
      String sql = "SELECT COUNT(u.id) FROM UserEntity u";
      Query q = em.createQuery(sql);
      return (long) q.getSingleResult();
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>As method was called internally there was no container callback available so the
new transaction was not created.
We need to inject bean for container would hook to it and could process annotations.</pre></div></div></aside></section>
<section id="_quiz_8"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class MyBean {
    @EJB
    private CityFinder cityBean;

    public void create(String name, String cityName) {
      UserEntity user = new UserEntity(name);
      em.persist(user);

      CityEntity city = cityBean.findCity(cityName);
      user.setHomeTown(city);
    }
 }

 @Stateless
 @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
 public class CityFinder {
    public CityEntity findCity(String cityName) {
      String q = "select c from CityEntity c where c.name=:name";
      Query query = Query.createQuery(q).setParameter("name", cityName);

      try{
        return (CityEntity) query.getSingleResult();
      } catch(NoResultException nre){
        return null;
      }
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Will this work?
Inspired at http://entjavastuff.blogspot.cz/2011/02/ejb-transaction-management-going-deeper.html</pre></div></div></aside></section>
<section id="_quiz_answer_7"><h2>Quiz - Answer</h2><div class="paragraph"><p>This fails as city was found in new transaction where em was closed at the end.
Entity became detached</p></div>
<div class="paragraph"><p>You set detached city entity reference to managed user entity.</p></div></section>
<section id="_exception_handling_2"><h2>Exception handling</h2><div class="paragraph"><p>Exception which causes rollback</p></div>
<div class="ulist"><ul><li><p>RuntimeException</p></li><li><p>EJBException</p></li><li><p>@ApplicationException(rollback = true, inherited = true)</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>EJBException extends RuntimeException, so...
intherited added to spec from EJB 3.1</pre></div></div></aside></section>
<section id="_quiz_9"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class MyBean {
    @EJB
    private MyBean thisBean;

    public void createNewUser(String name) {
      try {
        thisBean.doSomeWork();
      } catch (Exception e) {
        log.warn("The work failed but we will create user for you either");
      }

      UserEntity entity = new UserEntity(name);
      em.persist(entity);
    }

    public long doSomeWork() {
      // do some business but unfortunatelly something goes wrong...
      throw new RuntimeException();
    }
 }</code></pre></div></div></section>
<section id="_quiz_answer_8"><h2>Quiz - Answer</h2><div class="paragraph"><p>The transaction is marked as setRollbackOnly.</p></div>
<div class="paragraph"><p>As RuntimeException surpassed the bean boundaries container will marked it as rollback and
the whole transaction will be rollbacked nevertheless the exception was caught.</p></div></section>
<section id="_quiz_10"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class TableCreator {
    @Resource
    DataSource datasource;

    public void create() {
        try(Connection connection = datasource.getConnection()) {
            Statement st = connection.createStatement();
            st.execute(""CREATE TABLE user (id INTEGER NOT NULL UNIQUE, name VARCHAR(255))"");
        } catch (SQLException sqle) {
           // ignore this as table already exists
        }
    }
 }

 @Stateless
 public class Inserter {
   @PersistenceContext
   private EntityManager em;

   @EJB
   private TableCreator creator;

    public void call() {
        creator.create();

        UserEntity entity = new UserEntity("EAP QE");
        em.persist(entity);
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>We should close the connection on ours own. But in case the application server should close it for us at the end.
Btw. closing does not mean real closing. It just returns connection to pool.</pre></div></div>
<div class="literalblock"><div class="content"><pre>Expecting that datasource and the entity manager are configured to use the same datasource (sharing connection in fact).</pre></div></div></aside></section>
<section id="_quiz_answer_9"><h2>Quiz - Answer</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class TableCreator {
    @Resource
    DataSource datasource;

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void create() {
        try(Connection connection = datasource.getConnection()) {
            Statement st = connection.createStatement();
            st.execute(""CREATE TABLE user (id INTEGER NOT NULL UNIQUE, name VARCHAR(255))"");
        } catch (SQLException sqle) {
           // ignore this as table already exists
        }
    }
 }

 @Stateless
 public class Inserter {
   @EJB
   private TableCreator creator;

    public void call() {
        creator.create();

        UserEntity entity = new UserEntity("EAP QE");
        em.persist(entity);
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>If table already existed then as same database is used the internal DB transction is aborted and when we try to do some actions we
would get information that it's not possible as the DB transaction is in abort state.
  Caused by: org.postgresql.util.PSQLException: ERROR: current transaction is aborted, commands ignored until end of transaction block</pre></div></div></aside></section>
<section id="_transaction_context_propagation"><h2>Transaction context propagation</h2><div class="ulist"><ul><li><p>propagation works from BMT to CMT</p></li><li><p>NOT propagated to BMT</p><div class="ulist"><ul><li><p>transaction from BMT is suspended</p></li></ul></div></li></ul></div></section>
<section id="_cmt_bmt_not_propagated"><h2>CMT &#8594; BMT - not propagated</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void BmtBean {
   public void do() {
     // do something
   }
 }

 @Stateless
 public class CmtBean {
    @EJB
    private BmtBean bean;

    public void work() {
      bean.do();
    }
 }</code></pre></div></div></section>
<section id="_bmt_cmt_propagated"><h2>BMT &#8594; CMT - propagated</h2><div class="listingblock"><div class="content"><pre class="highlight"><code  class="stretch java language-java"> @Stateless
 public class CmtBean {
    public void work() {
      // do something
    }
 }

 @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void BmtBean {
   @Resource
   UserTransaction utx;

   @EJB
   private CmtBean bean;

   public void method() {
     try {
        utx.begin();
        bean.work();
        utx.commit();
     } catch(Exception e) {
        ut.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_cdi_transactional_management"><h2>CDI transactional management</h2></section>
<section id="__transactional_and_transactionscoped"><h2>@Transactional and @TransactionScoped</h2><div class="ulist"><ul><li><p>@Transactional</p><div class="ulist"><ul><li><p>javax.transaction.TxType value</p></li><li><p>Class[] rollbackOn</p></li><li><p>Class[] dontRollbackOn</p></li></ul></div></li><li><p>@TransactionScoped</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Exception handling - RuntimeException should cause the rollback is provided. But there is a question that I do not know
  that injected CDI bean inside other CDI bean does not cause that the transaction would be marked as rollback only.</pre></div></div></aside></section>
<section id="_references"><h2>References</h2><div class="ulist"><ul><li><p>Presentation <a href="https://github.com/ochaloup/ts-presentation" class="bare">https://github.com/ochaloup/ts-presentation</a></p></li><li><p>Java Transaction Design Strategies <a href="http://www.infoq.com/minibooks/JTDS" class="bare">http://www.infoq.com/minibooks/JTDS</a></p></li><li><p>Transakce v Java EE (Kamil Å eveÄek) <a href="https://www.youtube.com/watch?v=6q9NIRBHd5I" class="bare">https://www.youtube.com/watch?v=6q9NIRBHd5I</a></p></li><li><p>Java Transaction Processing <a href="http://www.amazon.com/Java-Transaction-Processing-Design-Implementation/dp/013035290X" class="bare">http://www.amazon.com/Java-Transaction-Processing-Design-Implementation/dp/013035290X</a></p></li><li><p>My bookmarks on <a href="http://delicious.com/chalda/ts.presentation" class="bare">http://delicious.com/chalda/ts.presentation</a></p></li></ul></div></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.min.js"></script><script type="text/javascript">// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: false,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, blond, default, moon, night, serif, simple, sky, solarized)
  theme: Reveal.getQueryHash().theme || 'redhat',
  // Transition style (e.g., default, cube, page, concave, zoom, linear, fade, none)
  transition: Reveal.getQueryHash().transition || 'default',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., default, none, slide, concave, convex, zoom)
  backgroundTransition: 'default',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>