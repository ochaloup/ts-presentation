<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Ondra Chaloupka / ochaloup@redhat.com"><title>Transaction Management in Java EE</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.min.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme"><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script type="text/javascript">document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section><h2>Transaction Management in Java EE</h2><p><small>Ondra Chaloupka / ochaloup@redhat.com</small></p></section><section id="_there_is_a_transaction"><h2>There is a transaction?</h2><div class="paragraph"><p><span class="image"><img src="./misc/entertain/wtf.jpg" alt="wtf"></span></p></div></section>
<section id="_summary_terminology"><h2>Summary - Terminology</h2><div class="ulist"><ul><li><p>ACID (Atomic, Consistent, Isolated, Durable)</p></li><li><p>Resource local vs. Global vs. Distributed</p></li><li><p>XA is (not) Distributed transaction</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Transactions summary from slides1.adoc session
* We are talking about ACID transactions - need to know - no other txn is discussed here
* Resource local is transaction of resource (DB, JMS), Global is txn managed by outter entity (e.g. TM), distributed is having transaction context flowing through multiple TMs
* for Narayana speak we difference XA and Distributed - more resources could be part of a XA transaction, distributed means the transaction is spread over more TM</pre></div></div></aside></section>
<section id="_summary_db_and_jms"><h2>Summary - DB and JMS</h2><div class="ulist"><ul><li><p>Databases</p><div class="ulist"><ul><li><p>relaxing isolation for better concurrency</p></li><li><p><code>setAutoCommit(false)</code></p></li><li><p>DDL commands are not transactional in all DBs</p></li></ul></div></li><li><p>JMS</p><div class="ulist"><ul><li><p>Connection.createSession(boolean transacted, int acknowledgeMode)</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Databases and JMS
* Transaction isolation is a function of database cocurrency and database consistency - more isolation, means more consistency but less concurrency
* how to start longer transaction by JDBC call - setautocommit (e.g. postgres run any SQL query in transaction but if we want a transaction being spread over more SQL commands then we use setautocommit to false)</pre></div></div></aside></section>
<section id="_summary_jta"><h2>Summary - JTA</h2><div class="ulist"><ul><li><p>XA specification in Java</p><div class="ulist"><ul><li><p>XA means more resource enlisted in one global transaction</p></li></ul></div></li><li><p>implemented by Transaction manager</p></li><li><p>TM works with XAResource</p></li><li><p>in Java EE transaction should be hidden from developer</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Java app server hides transaction from developer
* CMT - you are expected not to touch anything and just define behaviour by annotations
* BMT - you are exepected to inject UserTransaction and use it</pre></div></div></aside></section>
<section id="_jta_vs_jts"><h2>JTA vs. JTS</h2><div class="paragraph"><p>Difference of JTA to JTS has parallel in difference of JDBC to database driver.</p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>JTA is higher level api which uses application server, JTS is internal (low-level) api of TM how to communicate and manage transactional context.
The JTA is the interface developers use to manage transactions.
The Java Transaction Service (JTS) is the Java language mapping of the CORBA OTS 1.1 Specification (Object Transaction Service) - defines how to propagate transactions between multiple JTS transaction managers.
The Java Transaction Service (JTS), on the other hand, is an underlying transaction service that implements JTA.
Think of the relationship between JTA and JTS as similar to the relationship between JDBC and the corresponding underlying database driver; JTA is to JDBC as JTS is to the database driver.
JTS - used in CORBA where IIOP protocol to propagate transaction between multipe JTS TMs</pre></div></div>
<div class="literalblock"><div class="content"><pre>JTA is to JDBC as JTS is to the database driver</pre></div></div></aside></section>
<section id="_transactions_in_java_ee"><h2>Transactions in Java EE</h2><div class="paragraph"><p><span class="image"><img src="./misc/entertain/pocitac.jpg" alt="pocitac"></span></p></div></section>
<section id="_how_to_be_transactional"><h2>How to be transactional</h2><div class="ulist"><ul><li><p>EJB</p><div class="ulist"><ul><li><p>CMT - transactional by default</p></li><li><p>BMT - not transactional: <code>UserTransaction</code></p></li></ul></div></li><li><p>CDI - not transactional: <code>@Transactional</code></p></li><li><p>WebServlet - not transactional: <code>UserTransaction</code></p></li></ul></div></section>
<section id="_how_to_get_transaction"><h2>How to get transaction</h2><div class="ulist"><ul><li><p><code>@Resource/@Inject UserTransaction utx</code></p></li><li><p><code>@Resource SessionContext ctx
ctx.getUserTransaction()</code></p></li><li><p>jndi: <code>java:comp/UserTransaction</code></p></li><li><p>jndi: <code>java:jboss/TransactionManager</code></p></li><li><p><code>@Resource TransactionSynchronizationRegistry reg</code></p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>There could be one difference in @Resource and @Inject. WildFly checks whether @Resource annotation is used in EJB sesion or message driven bean when bean demarcation is specified.
UserTransaction is not permitted to be used in any other location (EjbExeption - IllegalStateException -JBAS011048: Failed to construct component instance)
You can't access UserTransaction interface either with use of SessionContext when you are not in bean managed demarcation (WildFly 8.2)
But by @Inject you can inject transaction in whatever location you want in general.
@Resource could be used in Servlet.</pre></div></div>
<div class="literalblock"><div class="content"><pre>UserTransaction can't be injected to EJB when it's CMT - you will get EjbException and application won't work
CMT could inject TransactionManager though</pre></div></div>
<div class="literalblock"><div class="content"><pre>Jndi for user transaction is defined by spec. Jndi for transaction manager is container specific.</pre></div></div></aside></section>
<section id="_ejb_bean_managed_transactions"><h2>EJB Bean-managed transactions</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   SessionContext ctx;

   public void method(){
     try {
        UserTransaction utx = ctx.getUserTransaction();
        utx.begin();
        ...
        utx.commit();
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Either in BMT or CMT we still touches global transaction managed by transaction manager. That's important to understand.
Programatic approach</pre></div></div></aside></section>
<section id="_bean_managed_limitations"><h2>Bean-managed limitations</h2><div class="ulist"><ul><li><p>Session beans (@Stateful, @Stateless, @Singleton)</p></li><li><p>Message driven beans (@MessageDriven)</p></li><li><p>Entity bean (EJB 2.0) can only be CMT</p></li><li><p>Stateful beans can&#8217;t use SessionSynchronization</p></li></ul></div></section>
<section id="_ejb_container_managed_transactions"><h2>EJB Container-managed transactions</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.CONTAINER)
 public class MyBean {
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void method() {
        // work with application managed resource
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Declarative approach
* mentioned annotations are not needed as they are default for a bean
*  work with application managed resource
   working directly e.g. with a database connection or jms session won't bring you transactional guarantees</pre></div></div></aside></section>
<section id="_annotations_under_use"><h2>Annotations under use</h2><div class="ulist"><ul><li><p>@TransactionManagement</p><div class="ulist"><ul><li><p>CONTAINER</p></li><li><p>BEAN</p></li></ul></div></li><li><p>@TransactionAttribute</p></li><li><p>@TransactionTimeout</p></li><li><p>@ApplicationException</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>@TransactionManagement - CONTAINER, BEAN (container is by default)
@TransactionAttribute - REQUIRED, REQUIRES_NEW... (required is by default)
@TransactionTimeout is jboss specific annotation - not part of EJB spec
@ApplicationException is put to user exception (standard or runtime) and defines if such exception should cause the rollback or not
  (RuntimeException could be marked for not causing the rollback)</pre></div></div>
<div class="literalblock"><div class="content"><pre>Each method is associated with *one* transaction. Neither nested or multiple transactions are not permitted.</pre></div></div></aside></section>
<section id="_transaction_attributes"><h2>Transaction attributes</h2><div class="ulist"><ul><li><p>REQUIRED</p></li><li><p>REQUIRES_NEW</p></li><li><p>MANDATORY</p></li><li><p>NOT_SUPPORTED</p></li><li><p>SUPPORTS</p></li><li><p>NEVER</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Resource: http://entjavastuff.blogspot.cz/2011/02/ejb-transaction-management-going-deeper.html
Attributes
* REQUIRED - no txn then new transaction is started or joining to existing txn
* REQUIRES_NEW - new transaction is started anytime
   - outer transaction is put to sleep until the inner EJB call finishes
   - note that the inner transaction does not share the managed entities of the outer transaction, they are completely isolated
* MANDATORY - no txn then EjbTransactionRequiredException or joining the existing txn
  - powerful tool that can help you to make your transactional code so much more robust - e.g. mark storage DAO methods that accept (managed) entities as a parameter as MANDATORY
* NOT_SUPPORTED - method runs without transaction anytime (no txn then nothing is done or suspend running txn)
  What could be useful for:
  - documentation. The annotation instantly tells you that the method does nothing transactional.
  - resources. There is always a cost in managing a transaction, so if the container doesn't have to, give it a break.
  - decreased whoops factor.  you'll catch transaction mistakes far sooner in your development cycle
* SUPPORTS - no txn then nothing is done (method runs without txn) or joining the existing txn
   - container is lazy :)
* NEVER - no txn then nothing is done (method runs without txn) or EJBException if calling method propagates some started txn
   - can be a useful tool to catch programming mistakes early on
   - when you make a call to another EJB, that EJB may safely create its own isolated transaction - NEVER may actually become a performance hog because of many mini-transactions being created</pre></div></div>
<div class="literalblock"><div class="content"><pre>When there is not transaction context active (ie. NOT_SUPPORTED) then for JMS autoack should be used and for database autoCommit is true.</pre></div></div></aside></section>
<section id="_transaction_enlistment"><h2>Transaction enlistment</h2><div class="paragraph"><p><span class="image"><img src="./misc/ee/example-bean-description.png" alt="example-bean-description"></span></p></div></section>
<section id="_component_iteractions_overview"><h2>Component iteractions overview</h2><div class="paragraph"><p><span class="image"><img src="./misc/ee/ee-component-iteractions.png" alt="ee-component-iteractions"></span></p></div></section>
<section id="_exception_handling"><h2>Exception handling</h2><div class="ulist"><ul><li><p>CMT - Exceptions which cause rollback</p><div class="ulist"><ul><li><p>RuntimeException</p></li><li><p>EJBException</p></li><li><p>@ApplicationException(rollback = true, inherited = true)</p></li></ul></div></li><li><p>BMT</p><div class="ulist"><ul><li><p>exceptions should be managed by developer</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>CMT:
EJBException extends RuntimeException, so...
intherited added to spec from EJB 3.1
BMT:
When RuntimeException is thrown from another bean - ie. when setRollbackOnly flag is set then then transaction can't be commited.
When you run commit you got Throwable and when you catch it and try to rollback then you get EJBException - no transaction!
But in fact transaction seems to be really rollbacked. So some automatic handling is available.</pre></div></div></aside></section>
<section id="_message_driven_bean"><h2>Message Driven Bean</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @MessageDriven(name = "MyMDB",
   activationConfig = {
      @ActivationConfigProperty( propertyName = "destinationType",
                                 propertyValue = "javax.jms.Queue"),
      @ActivationConfigProperty( propertyName = "destination",
                                 propertyValue ="/queue/testQueue")
   }
)
public class LibraryMessageBean implements MessageListener {

   @Resource
   private MessageDrivenContext mdctx;

   @EJB
   MyBean bean;

   public void onMessage(Message message) {
      // do something with the received message
   }
}</code></pre></div></div></section>
<section id="_message_driven_bean_bean_managed_transactions"><h2>Message Driven Bean - Bean-managed transactions</h2><div class="ulist"><ul><li><p>handled by JCA in-flow protocol</p></li><li><p>Bean managed transaction</p><div class="ulist"><ul><li><p>message receive is not part of transaction</p></li><li><p>you can start new transaction inside of onMessage method but received message is already acknowledged</p></li></ul></div></li><li><p>Container managed transaction</p><div class="ulist"><ul><li><p>REQUIRED - new transaction at onMessage method start</p></li><li><p>NOT_SUPPORTED - no transaction - acknowledge mode</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>transaction context does not flow with a JMS message - this means that it should be duty of RA to manage transactions here</pre></div></div></aside></section>
<section id="_quiz"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method(){
     try {
        utx.begin();
        ...
        // utx.commit(); &lt;---
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>A bit tricky :) here. Session bean is CONTAINER managed by default.
This will throw an EJBException</pre></div></div></aside></section>
<section id="_quiz_2"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method() {
     try {
        utx.begin();
        ...
        // utx.commit(); &lt;---
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_quiz_contd"><h2>Quiz (contd.)</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateful
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method() {
     try {
        utx.begin();
        ...
        // utx.commit(); &lt;---
     } catch(Exception e) {
        utx.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_quiz_answer_for_bmt"><h2>Quiz - Answer - for BMT!</h2><div class="ulist"><ul><li><p>Stateless, Singleton, MDB: EJB container ensures that transaction won&#8217;t leave a method uncommitted</p><div class="ulist"><ul><li><p>EJBException ("should complete transaction before returning") + rollback done by container</p></li></ul></div></li><li><p>Stateful: transaction can flow over several method invocations on the same SFSB instance</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Limitation of @Stateless bean to commit transaction came from the fact (probably) that nested transactions
are not supported by JTA (&lt;- really not sure with this statement)</pre></div></div>
<div class="literalblock"><div class="content"><pre>For stateful bean the transaction could be span e.g. over several http calls.</pre></div></div></aside></section>
<section id="_quiz_3"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void MyBean {
   @Resource
   UserTransaction utx;

   public void method() {
     try {
        utx.begin();
        utx.setTransactionTimeout(30); // seconds
        ...
        utx.commit();
     } catch(Exception e) {
        ut.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_quiz_answer"><h2>Quiz - Answer</h2><div class="paragraph"><p>Nothing will happen. Transaction timeout has to be set before the transaction is started.</p></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Default jboss transaction timeout is 5 minutes (default-timeout of transactions subsystem).</pre></div></div></aside></section>
<section id="_quiz_4"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class MyBean {
    @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
    public void method() {
        // do some work with database here
    }
 }</code></pre></div></div></section>
<section id="_quiz_5"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class MyBean {

    public void createNewUser(String name) {
      UserEntity user = new UserEntity(name);
      em.persist(user);

      long numberOfUsersBeforeCommit = getNumberOfUsers();
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public long getNumberOfUsers() {
      String sql = "SELECT COUNT(u.id) FROM UserEntity u";
      Query q = em.createQuery(sql);
      return (long) q.getSingleResult();
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Will the getNumberOfUsers know about newly created entity user from createNewUser?</pre></div></div></aside></section>
<section id="_quiz_answer_2"><h2>Quiz - Answer</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class MyBean {
    @EJB
    private MyBean thisBean;

    public void createNewUser(String name) {
      UserEntity user = new UserEntity(name);
      em.persist(user);

      long numberOfUsersBeforeCommit = thisBean.getNumberOfUsers();
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public long getNumberOfUsers() {
      String sql = "SELECT COUNT(u.id) FROM UserEntity u";
      Query q = em.createQuery(sql);
      return (long) q.getSingleResult();
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>As method was called internally there was no container callback available so the
new transaction was not created.
We need to inject bean for container would hook to it and could process annotations.</pre></div></div></aside></section>
<section id="_quiz_6"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class MyBean {
    @EJB
    private CityFinder cityBean;

    public void create(String name, String cityName) {
      UserEntity user = new UserEntity(name);
      em.persist(user);

      CityEntity city = cityBean.findCity(cityName);
      user.setHomeTown(city);
    }
 }

 @Stateless
 @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
 public class CityFinder {
    public CityEntity findCity(String cityName) {
      String q = "select c from CityEntity c where c.name=:name";
      Query query = Query.createQuery(q).setParameter("name", cityName);

      try{
        return (CityEntity) query.getSingleResult();
      } catch(NoResultException nre){
        return null;
      }
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Will this work?
Inspired at http://entjavastuff.blogspot.cz/2011/02/ejb-transaction-management-going-deeper.html</pre></div></div></aside></section>
<section id="_quiz_answer_3"><h2>Quiz - Answer</h2><div class="paragraph"><p>City is found in a new transaction. Entity manager is closed at the end of that transaction -
at the end of method <code>findCity</code>.</p></div>
<div class="paragraph"><p><strong>Result:</strong> Entity became detached.</p></div>
<div class="paragraph"><p>Detached <code>CityEntity</code> reference is being set to managed <code>UserEntity</code>.</p></div></section>
<section id="_quiz_7"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class MyBean {
    @EJB
    private MyBean thisBean;

    public void createNewUser(String name) {
      try {
        thisBean.doSomeWork();
      } catch (Exception e) {
        log.warn("The work failed but we will still create user for you");
      }

      UserEntity entity = new UserEntity(name);
      em.persist(entity);
    }

    public long doSomeWork() {
      // do some business but unfortunatelly something goes wrong...
      throw new RuntimeException();
    }
 }</code></pre></div></div></section>
<section id="_quiz_answer_4"><h2>Quiz - Answer</h2><div class="paragraph"><p>The transaction is marked as setRollbackOnly.</p></div>
<div class="paragraph"><p>As RuntimeException surpassed the bean boundaries and container will mark it for rollback.</p></div>
<div class="paragraph"><p><strong>Result:</strong> transaction will be rollbacked despite catching the exception.</p></div></section>
<section id="_quiz_8"><h2>Quiz</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class TableCreator {
    @Resource
    DataSource datasource;

    public void create() {
        try(Connection connection = datasource.getConnection()) {
            Statement st = connection.createStatement();
            st.execute("CREATE TABLE user (id INTEGER NOT NULL, name VARCHAR(255))");
        } catch (SQLException sqle) {
           // ignore this as table already exists
        }
    }
 }

 @Stateless
 public class Inserter {
   @PersistenceContext
   private EntityManager em;

   @EJB
   private TableCreator creator;

    public void call() {
        creator.create();

        UserEntity entity = new UserEntity(1, "EAP QE");
        em.persist(entity);
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>We should close the connection on ours own. But in case the application server should close it for us at the end.
Btw. closing does not mean real closing. It just returns connection to pool.</pre></div></div>
<div class="literalblock"><div class="content"><pre>Expecting that datasource and the entity manager are configured to use the same datasource (sharing connection in fact).</pre></div></div></aside></section>
<section id="_quiz_answer_5"><h2>Quiz - Answer</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class TableCreator {
    @Resource
    DataSource datasource;

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void create() {
        try(Connection connection = datasource.getConnection()) {
            Statement st = connection.createStatement();
            st.execute("CREATE TABLE user (id INTEGER NOT NULL, name VARCHAR(255))");
        } catch (SQLException sqle) {
           // ignore this as table already exists
        }
    }
 }

 @Stateless
 public class Inserter {
   @EJB
   private TableCreator creator;

    public void call() {
        creator.create();

        UserEntity entity = new UserEntity(1, "EAP QE");
        em.persist(entity);
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>If table already existed then as same database is used the internal DB transction is aborted and when we try to do some actions we
would get information that it's not possible as the DB transaction is in abort state.
  Caused by: org.postgresql.util.PSQLException: ERROR: current transaction is aborted, commands ignored until end of transaction block</pre></div></div></aside></section>
<section id="_quiz_webservlet"><h2>Quiz - WebServlet</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @WebServlet(name="transaction", urlPatterns={"/transaction"})
 public class WebServletTransactionRun extends HttpServlet {
    @EJB
    private StatefulBean bean; // defined as @Stateful

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response)
        throws ServletException, IOException {
      bean.doWork();
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>What could be wrong here?
Stateful will be injected only once and as Servlet behaves as singleton - one instance manages more http requests
then you can be surprised that not each session or http request gets its own SFSB
The similar is for @Inject as default scope is @Dependent that behaves like @EJB - it injects CDI bean to servlet
and the CDI bean is removed when the component (WebServlet) is removed</pre></div></div></aside></section>
<section id="_quiz_webservlet_anser_1"><h2>Quiz - WebServlet - Anser #1</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @WebServlet(name="transaction", urlPatterns={"/transaction"})
 public class WebServletTransactionRun extends HttpServlet {

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response)
        throws ServletException, IOException {

      StatefulBean bean = (StatefulBean) request.getSession().getAttribute("sfsb");

      if(bean == null) {
        try {
          InitialContext ic = new InitialContext();
          bean = (StatefulBean) ic.lookup("java:app/StatefulBean");

          request.getSession().setAttribute("sfsb", bean);
        } catch (NamingException e) {
          throw new ServletException(e);
        }
      }

      bean.doWork();
    }
 }</code></pre></div></div></section>
<section id="_quiz_webservlet_answer_2"><h2>Quiz - WebServlet - Answer #2</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @WebServlet(name="transaction", urlPatterns={"/transaction"})
 public class WebServletTransactionRun extends HttpServlet {

    @Inject
    StatefulBean bean;

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response)
        throws ServletException, IOException {
      bean.doWork();
    }
 }

 @Stateful
 @SessionScoped
 public class StatefulBean {
  ....
 }</code></pre></div></div></section>
<section id="_quiz_webservlet_usertransaction"><h2>Quiz - WebServlet - UserTransaction</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @WebServlet(name="transaction", urlPatterns={"/transaction"})
 public class WebServletTransactionRun extends HttpServlet {

    @Resource
    UserTransaction utx;

    @EJB
    StatelessBean bean;

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response)
        throws ServletException, IOException {
      try {
        utx.begin();
        bean.doWork();
        utx.commit();
      } catch (Exception e) {
        ...
      }
    }
 }</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>User transaction object is thread safe and the transaction is used from different threads
so this will work fine thread safe means that transaction is bound to a thread {@link ThreadLocal} and it's
not problem for TM that one single instance of WebServlet manages more user requests</pre></div></div></aside></section>
<section id="_transaction_context_propagation"><h2>Transaction context propagation</h2><div class="ulist"><ul><li><p>transaction is propagated from Bean-managed transaction to Container-managed transaction</p></li><li><p>transaction is <strong>not</strong> propagated from Container-managed transaction to Bean-managed transaction</p><div class="ulist"><ul><li><p>transaction in BMT is suspended and CMT (possibly) starts new one</p></li></ul></div></li></ul></div></section>
<section id="_bmt_cmt_propagated"><h2>BMT &#8594; CMT - propagated</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public class CmtBean {
    public void work() {
      // do something
    }
 }

 @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void BmtBean {
   @Resource
   UserTransaction utx;

   @EJB
   private CmtBean bean;

   public void method() {
     try {
        utx.begin();
        bean.work();
        utx.commit();
     } catch(Exception e) {
        ut.rollback();
     }
   }
 }</code></pre></div></div></section>
<section id="_cmt_bmt_not_propagated"><h2>CMT &#8594; BMT - not propagated</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 @TransactionManagement(TransactionManagementType.BEAN)
 public void BmtBean {
   public void do() {
     // do something
   }
 }

 @Stateless
 public class CmtBean {
    @EJB
    private BmtBean bean;

    public void work() {
      bean.do();
    }
 }</code></pre></div></div></section>
<section id="_cdi_transactional_management"><h2>CDI transactional management</h2></section>
<section id="__transactional_and_transactionscoped"><h2>@Transactional and @TransactionScoped</h2><div class="ulist"><ul><li><p>@Transactional</p><div class="ulist"><ul><li><p>javax.transaction.TxType value</p></li><li><p>Class[] rollbackOn</p></li><li><p>Class[] dontRollbackOn</p></li></ul></div></li><li><p>@TransactionScoped</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Exception handling - RuntimeException should cause the rollback is provided. But there is a question that I do not know
  that injected CDI bean inside other CDI bean does not cause that the transaction would be marked as rollback only.</pre></div></div></aside></section>
<section id="_jboss_sources_configuration"><h2>JBoss sources configuration</h2></section>
<section id="_datasource"><h2>Datasource</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="xml language-xml">  &lt;datasource jta="true" jndi-name="java:jboss/datasource-test" pool-name="datasource-test"
              enabled="true" use-java-context="true" spy="true"&gt;
      &lt;connection-url&gt;jdbc:postgresql://localhost:5432/crashrec&lt;/connection-url&gt;
      &lt;driver&gt;database-jdbc-driver.jar&lt;/driver&gt;
      &lt;security&gt;
          &lt;user-name&gt;crashrec&lt;/user-name&gt;
          &lt;password&gt;crashrec&lt;/password&gt;
      &lt;/security&gt;
      &lt;transaction-isolation&gt;TRANSACTION_READ_COMMITTED&lt;/transaction-isolation&gt;
  &lt;/datasource&gt;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Note datasource attribute jta here which could be true/false - jta datasource or non-jta datasource</pre></div></div></aside></section>
<section id="_xa_datasource"><h2>XA Datasource</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="xml language-xml">  &lt;xa-datasource jndi-name="java:jboss/xa-datasource-test" pool-name="xa-datasource-test"
                 enabled="true" spy="true"&gt;
      &lt;xa-datasource-property name="PortNumber"&gt;
          5432
      &lt;/xa-datasource-property&gt;
      &lt;xa-datasource-property name="ServerName"&gt;
          localhost
      &lt;/xa-datasource-property&gt;
      &lt;xa-datasource-property name="DatabaseName"&gt;
          crashrec
      &lt;/xa-datasource-property&gt;
      &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
      &lt;driver&gt;database-jdbc-driver.jar&lt;/driver&gt;
      &lt;security&gt;
          &lt;user-name&gt;crashrec&lt;/user-name&gt;
          &lt;password&gt;crashrec&lt;/password&gt;
      &lt;/security&gt;
  &lt;/xa-datasource&gt;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>From testing point of view where different databases are used is necessary to know which xa-datasource-property is used
in what jdbc driver (e.g. Oracle understand the URL property which is jdbc url and no other database does so)</pre></div></div></aside></section>
<section><section id="_jms_configuration_hornetq"><h2>JMS configuration (HornetQ)</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="xml language-xml">  &lt;jms-connection-factories&gt;
      &lt;connection-factory name="InVmConnectionFactory"&gt;
          &lt;connectors&gt;
              &lt;connector-ref connector-name="in-vm"/&gt;
          &lt;/connectors&gt;
          &lt;entries&gt;
              &lt;entry name="java:/ConnectionFactory"/&gt;
          &lt;/entries&gt;
      &lt;/connection-factory&gt;
      &lt;connection-factory name="RemoteConnectionFactory"&gt;
          &lt;connectors&gt;
              &lt;connector-ref connector-name="http-connector"/&gt;
          &lt;/connectors&gt;
          &lt;entries&gt;
              &lt;entry name="java:jboss/exported/jms/RemoteConnectionFactory"/&gt;
          &lt;/entries&gt;
      &lt;/connection-factory&gt;
      &lt;pooled-connection-factory name="hornetq-ra"&gt;
          &lt;transaction mode="xa"/&gt;
          &lt;connectors&gt;
              &lt;connector-ref connector-name="in-vm"/&gt;
          &lt;/connectors&gt;
          &lt;entries&gt;
              &lt;entry name="java:/JmsXA"/&gt;
              &lt;entry name="java:jboss/DefaultJMSConnectionFactory"/&gt;
          &lt;/entries&gt;
      &lt;/pooled-connection-factory&gt;
  &lt;/jms-connection-factories&gt;

  &lt;jms-destinations&gt;
      &lt;jms-queue name="ExpiryQueue"&gt;
          &lt;entry name="java:/jms/queue/ExpiryQueue"/&gt;
      &lt;/jms-queue&gt;
      &lt;jms-queue name="DLQ"&gt;
          &lt;entry name="java:/jms/queue/DLQ"/&gt;
      &lt;/jms-queue&gt;
  &lt;/jms-destinations&gt;</code></pre></div></div><aside class="notes"><div class="literalblock"><div class="content"><pre>Messaging is configured only in -full profiles</pre></div></div></aside></section><section id="_bonus_jpa"><h2>Bonus: JPA</h2><div class="paragraph"><p><span class="image"><img src="./misc/entertain/kartoteka1.jpg" alt="kartoteka1"></span></p></div></section><section id="_jpa_overview_in_short"><h2>JPA overview in short</h2><div class="ulist"><ul><li><p>ORM (Object-relational mapping)</p></li><li><p>EclipseLink (reference), Hibernate (JBoss)</p></li><li><p>Benefits (theoretically)</p><div class="ulist"><ul><li><p>staying in object oriented world</p></li><li><p>independent on underlaying database</p></li><li><p>simplified CRUD</p></li><li><p>JPQL (db independent + simplified join queries)</p></li><li><p>automatic table creation (hbm2dll)</p></li><li><p>performance (lazy dml, batching sql, 2nd level cache)</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Resource: http://www.javatpoint.com/hibernate-tutorial, http://www.journaldev.com/2882/hibernate-tutorial-for-beginners-using-xml-annotations-and-property-configurations</pre></div></div></aside></section><section id="_sql_table_creation"><h2>SQL table creation</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="sql language-sql"> CREATE TABLE PERSON (
   id INTEGER NOT NULL DEFAULT ('person_seq'),
   username VARCHAR(255),
   birthdate DATE,
   ...
 )</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>PostgreSQL sequence: reate sequence person_seq increment 1 start 1;</pre></div></div></aside></section><section id="_java_entity_definition"><h2>Java entity definition</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Entity
 @Table("person")
 public class Person {
   @Id
   @GeneratedValue
   private int id;

   private String username;

   @Temporal(TemproalType.DATE)
   private Date birthDate;

   @ManyToMany
   @JoinTable(name = "PERSON_GROUP",
     joinColumn = @JoinColumn(name = "person_id"),
     inverseJoinColumn = @JoinColumn(name = "group_id"))
   private List&lt;Groups&gt; groups;

   ...
 }</code></pre></div></div></section><section id="_entity_manager_in_java_se"><h2>Entity Manager in Java SE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> EntityManagerFactory emf = Persistence.createEntityManagerFactory("MyPersistenceUnit");
 EntityManager em = emf.createEntityManager();

 em.getTransaction().begin();

 Person person = new Person();
 person.setName("JBoss EAP 6");

 em.persist(person);

 em.getTransaction().commit();

 em.close();
 emf.close();</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>TODO: I haven't found a way how to not use a transaction for persist action will be reflected in database.
      Setting autoCommit to true in persistence.xml does not help in this (at least for RESOURCE_LOCAL)
      I think that autoCommit settings is used for JPA when TransactionAttribute NOT_SUPPORTED is used.
em.getTranaction() is type of EntityTransaction
em.clear() - clear persistence context</pre></div></div></aside></section><section id="_entity_manager_in_java_ee"><h2>Entity Manager in Java EE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java"> @Stateless
 public SomeBean() {
   @PersistenceContext
   EntityManager em;

   public void newPerson() {
     Person person = new Person();
     person.setName("JBoss EAP 6");
     em.persist(person);
   }
 }</code></pre></div></div></section><section id="_persistence_xml_in_java_se"><h2>Persistence.xml in Java SE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="xml language-xml">  &lt;persistence-unit name="ResourceLocalPersistenceUnit" transaction-type="RESOURCE_LOCAL"&gt;
      &lt;class&gt;org.jboss.qa.tspresentation.Person&lt;/class&gt;

      &lt;properties&gt;
          &lt;property name="hibernate.connection.url"
                    value="jdbc:postgresql://localhost:5432/crashrec?loglevel=2"/&gt;
          &lt;property name="hibernate.dialect"
                    value="org.hibernate.dialect.PostgreSQL82Dialect"/&gt;
          &lt;property name="hibernate.connection.driver_class" value="org.postgresql.Driver"/&gt;
          &lt;property name="hibernate.connection.username" value="crashrec"/&gt;
          &lt;property name="hibernate.connection.password" value="crashrec"/&gt;

          &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;

          &lt;property name="hibernate.show_sql" value="true"/&gt;
          &lt;property name="hibernate.format_sql" value="true"/&gt;
      &lt;/properties&gt;
  &lt;/persistence-unit&gt;</code></pre></div></div></section><section id="_persistence_xml_in_java_ee"><h2>Persistence.xml in Java EE</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="xml language-xml"> &lt;persistence-unit name="TestPersistenceUnit" transaction-type="JTA"&gt;
      &lt;jta-data-source&gt;java:jboss/datasource-test&lt;/jta-data-source&gt;

      &lt;properties&gt;
          &lt;property name="hibernate.dialect"
                    value="org.hibernate.dialect.PostgreSQL82Dialect"/&gt;
          &lt;property name="hibernate.temp.use_jdbc_metadata_defaults" value="true" /&gt;

          &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;

          &lt;property name="hibernate.show_sql" value="true"/&gt;
          &lt;property name="hibernate.format_sql" value="true"/&gt;
      &lt;/properties&gt;
  &lt;/persistence-unit&gt;</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>What I understand when I define dialect and use hibernate.temp.use_jdbc_metadata_defaults then Hibernate does not need to ask for metatadata
from the database and there are not done some first quering of database
Beside jta-data-source there is tag non-jta-data-source bug JBoss(WildFly 8.2) does not respect this and it only depends what is underlayin datasource
if datasource is jta=false then it always (doesn't matter what is tag for) used as non-transactional from TM point of view (autocommit=true)
if datasource is jta=true then it's joint to global TM if exists</pre></div></div></aside></section><section id="_em_flush_and_em_clear"><h2>em.flush() and em.clear()</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin();
  Person person = em.find(Person.java, 1L);
  person.setName("JBoss EAP 7");
  // em.flush()
  em.getTransaction().commit();

  em.clear();</code></pre></div></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>EntityManager instance is 1st level cache. It contains all data that we used and it run SQLs to update database
just if it' necessary (it's lazy DML)
* em.flush()
* em.close() (application managed and extended-scoped pc)
* on commit transaction
* when using query and some entities are dirty
* driven by FlushModeType
** AUTO as stated above (default)
** COMMIT only on transaction commit (queries could get stale data)
Hibernate implementation does add MANUAL, NEVER, ALWAYS, PERSISTENCE_CONTEXT... see javadoc</pre></div></div>
<div class="literalblock"><div class="content"><pre>in Java EE em.clear() is called at the end of transaction
in Java SE the context (entity manager) is not cleared and it's up to developer when it should be cleared
  if context is full of data we can do some change of one particular item/record/entity and all other data
  which we don't know about their existence could be published to database simultaneouslly</pre></div></div>
<div class="literalblock"><div class="content"><pre>after clear() is called (or em is closed) the entities are detached and for the next usage it's need to
be attached to some entity manager (persitence context) by em.merge(entity_instance)</pre></div></div></aside></section><section id="_transactions_in_jpa"><h2>Transactions in JPA</h2><div class="ulist"><ul><li><p>Transaction management defined by transaction-type (persistence.xml)</p><div class="ulist"><ul><li><p>RESOURCE_LOCAL</p></li><li><p>JTA</p></li></ul></div></li><li><p>Relatet to type of persistence context</p></li><li><p>Any update operation has to be proceeded inside of a transaction</p></li><li><p>Read operation could be proceeded out of the transaction</p></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>In Java SE working with EntityTransaction, in Java EE with global transaction. It's problematic to use autocommit=true.
In fact autocommit=true is probably (!) used when NOT_SUPPORTED for transaction is used. For Java SE it's probably(!) necessary
to directly touch underlaying connection as normally EntityTransaction has to be started and it's not possible to change it by some
easily accesible settings or API.</pre></div></div>
<div class="literalblock"><div class="content"><pre>NOTE: all this tested on PostgreSQL</pre></div></div></aside></section><section id="_persistence_context_types"><h2>Persistence context types</h2><div class="ulist"><ul><li><p>Application-managed</p><div class="ulist"><ul><li><p>RESOURCE_LOCAL/Java SE</p></li><li><p>ends (is cleared) on manual call of clear method or em.remove(entity)</p></li></ul></div></li><li><p>Container-managed: Transaction-scoped</p><div class="ulist"><ul><li><p>ends at the end of transaction</p></li></ul></div></li><li><p>Container-managed: Extended</p><div class="ulist"><ul><li><p>used only with SFSB</p></li><li><p>ends when SFSB method <code>@Remove</code> is called</p></li><li><p>during the time several transactions could be committed</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="literalblock"><div class="content"><pre>Java SE is not precondition here but it's standard to do it so. The application managed is more bound to
transaction-type attribute where here it's resource local</pre></div></div>
<div class="literalblock"><div class="content"><pre>Persistence context type is set by @PersistenceContext annotation and types like PersistenceContextType.TRANSACTION (default)
and PersistenceContextType.EXTENDED</pre></div></div>
<div class="literalblock"><div class="content"><pre>When persitence context ends then it's flushed and cleared = all entities started to be detached</pre></div></div></aside></section><section id="_a_side_note_locking"><h2>A side note: locking</h2><div class="ulist"><ul><li><p>Optimistic</p><div class="ulist"><ul><li><p><code>@Version</code> at attribute</p></li><li><p><code>em.lock(person, LockModeType.OPTIMISTIC)</code></p></li></ul></div></li><li><p>Pesimistic</p><div class="ulist"><ul><li><p><code>em.lock(persion, LockModeType.PESIMISTIC_WRITE)</code></p></li></ul></div></li></ul></div></section></section>
<section id="_references"><h2>References</h2><div class="ulist"><ul><li><p>Presentation <a href="https://github.com/ochaloup/ts-presentation/blob/master/slides/slides1.adoc" class="bare">https://github.com/ochaloup/ts-presentation/blob/master/slides/slides1.adoc</a></p></li><li><p>Presentation #2 <a href="https://github.com/ochaloup/ts-presentation/blob/master/slides/slides1b.adoc" class="bare">https://github.com/ochaloup/ts-presentation/blob/master/slides/slides1b.adoc</a></p></li><li><p>Java Transaction Design Strategies <a href="http://www.infoq.com/minibooks/JTDS" class="bare">http://www.infoq.com/minibooks/JTDS</a></p></li><li><p>Transakce v Java EE (Kamil Ševeček) <a href="https://www.youtube.com/watch?v=6q9NIRBHd5I" class="bare">https://www.youtube.com/watch?v=6q9NIRBHd5I</a></p></li><li><p>Java Transaction Processing <a href="http://www.amazon.com/Java-Transaction-Processing-Design-Implementation/dp/013035290X" class="bare">http://www.amazon.com/Java-Transaction-Processing-Design-Implementation/dp/013035290X</a></p></li><li><p>Bookmarks at <a href="http://delicious.com/chalda/ts.presentation" class="bare">http://delicious.com/chalda/ts.presentation</a></p></li></ul></div></section>
<section id="_"><h2>?!</h2><div class="paragraph"><p><span class="image"><img src="./misc/entertain/cajk.jpg" alt="cajk"></span></p></div></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.min.js"></script><script type="text/javascript">// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: false,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, blond, default, moon, night, serif, simple, sky, solarized)
  theme: Reveal.getQueryHash().theme || 'redhat',
  // Transition style (e.g., default, cube, page, concave, zoom, linear, fade, none)
  transition: Reveal.getQueryHash().transition || 'default',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., default, none, slide, concave, convex, zoom)
  backgroundTransition: 'default',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>